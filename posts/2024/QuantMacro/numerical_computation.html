<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="岩永悠希">
<meta name="dcterms.date" content="2024-10-11">

<title>定量的マクロ経済学における数値計算の基礎 – Yuki Iwanaga</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../assets/images/network_icon_square_minty.png" rel="icon" type="image/png">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "?",
    "H"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-G4BZMT89L0"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-G4BZMT89L0', { 'anonymize_ip': true});
</script>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Zen+Kurenaido&amp;display=swap" rel="stylesheet">

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic&amp;display=swap" rel="stylesheet">
<style>
.menu-text {
  font-size: 120%;
}
</style>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles/styles.css">
<meta property="og:title" content="定量的マクロ経済学における数値計算の基礎 – Yuki Iwanaga">
<meta property="og:description" content="近年，定量的マクロ経済学 (quantitative macroeconomics) と呼ばれる領域では，数値計算 (numerical computation) 技術が必須の分析手法となっている．本稿では２期間モデルというシンプルなモデルを用いて，ハンズオンで数値計算の基礎を学ぶ．扱う手法は，グリッドサーチ，最適化アルゴリズム，求根問題，射影法，内生的グリッド法（執筆中）である．">
<meta property="og:image" content="https://nagayu71.github.io/posts/2024/QuantMacro/images/grid-search.png">
<meta property="og:site_name" content="Yuki Iwanaga">
<meta property="og:image:height" content="480">
<meta property="og:image:width" content="672">
<meta name="twitter:title" content="定量的マクロ経済学における数値計算の基礎 – Yuki Iwanaga">
<meta name="twitter:description" content="近年，定量的マクロ経済学 (quantitative macroeconomics) と呼ばれる領域では，数値計算 (numerical computation) 技術が必須の分析手法となっている．本稿では２期間モデルというシンプルなモデルを用いて，ハンズオンで数値計算の基礎を学ぶ．扱う手法は，グリッドサーチ，最適化アルゴリズム，求根問題，射影法，内生的グリッド法（執筆中）である．">
<meta name="twitter:image" content="https://nagayu71.github.io/posts/2024/QuantMacro/images/grid-search.png">
<meta name="twitter:image-height" content="480">
<meta name="twitter:image-width" content="672">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Yuki Iwanaga</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../links.html"> 
<span class="menu-text">Links</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/Nagayu71" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">定量的マクロ経済学における数値計算の基礎</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Macroeconomics</div>
                <div class="quarto-category">Computation</div>
                <div class="quarto-category">Python</div>
                <div class="quarto-category">SciPy</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>岩永悠希 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 11, 2024</p>
      </div>
    </div>
    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">October 11, 2024</p>
      </div>
    </div>
      
    </div>
    
  <div>
    <div class="abstract">
      <div class="block-title">概要</div>
      近年，定量的マクロ経済学 (quantitative macroeconomics) と呼ばれる領域では，数値計算 (numerical computation) 技術が必須の分析手法となっている．本稿では２期間モデルというシンプルなモデルを用いて，ハンズオンで数値計算の基礎を学ぶ．扱う手法は，グリッドサーチ，最適化アルゴリズム，求根問題，射影法，内生的グリッド法（執筆中）である．
    </div>
  </div>
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2">
    <h2 id="toc-title">目次</h2>
   
  <ul>
  <li><a href="#はじめに" id="toc-はじめに" class="nav-link active" data-scroll-target="#はじめに"><span class="header-section-number">1</span> はじめに</a></li>
  <li><a href="#ベンチマークモデルとカリブレーション" id="toc-ベンチマークモデルとカリブレーション" class="nav-link" data-scroll-target="#ベンチマークモデルとカリブレーション"><span class="header-section-number">2</span> ベンチマーク・モデルとカリブレーション</a>
  <ul>
  <li><a href="#ベンチマークモデル２期間モデル" id="toc-ベンチマークモデル２期間モデル" class="nav-link" data-scroll-target="#ベンチマークモデル２期間モデル"><span class="header-section-number">2.1</span> ベンチマーク・モデル：２期間モデル</a></li>
  <li><a href="#カリブレーション" id="toc-カリブレーション" class="nav-link" data-scroll-target="#カリブレーション"><span class="header-section-number">2.2</span> カリブレーション</a></li>
  <li><a href="#解析解の性質" id="toc-解析解の性質" class="nav-link" data-scroll-target="#解析解の性質"><span class="header-section-number">2.3</span> 解析解の性質</a></li>
  </ul></li>
  <li><a href="#実践数値計算" id="toc-実践数値計算" class="nav-link" data-scroll-target="#実践数値計算"><span class="header-section-number">3</span> 【実践】数値計算</a>
  <ul>
  <li><a href="#離散近似とグリッド" id="toc-離散近似とグリッド" class="nav-link" data-scroll-target="#離散近似とグリッド"><span class="header-section-number">3.1</span> 離散近似とグリッド</a>
  <ul class="collapse">
  <li><a href="#グリッド上で計算する" id="toc-グリッド上で計算する" class="nav-link" data-scroll-target="#グリッド上で計算する"><span class="header-section-number">3.1.1</span> グリッド上で計算する</a></li>
  </ul></li>
  <li><a href="#sec-grid-search" id="toc-sec-grid-search" class="nav-link" data-scroll-target="#sec-grid-search"><span class="header-section-number">3.2</span> 状態変数と制御変数がともに離散の場合：グリッドサーチ</a>
  <ul class="collapse">
  <li><a href="#注意点次元の呪い" id="toc-注意点次元の呪い" class="nav-link" data-scroll-target="#注意点次元の呪い"><span class="header-section-number">3.2.1</span> 注意点：次元の呪い</a></li>
  <li><a href="#sec-obj-oriented" id="toc-sec-obj-oriented" class="nav-link" data-scroll-target="#sec-obj-oriented"><span class="header-section-number">3.2.2</span> オブジェクト指向プログラミング</a></li>
  </ul></li>
  <li><a href="#sec-optimize" id="toc-sec-optimize" class="nav-link" data-scroll-target="#sec-optimize"><span class="header-section-number">3.3</span> 最適化アルゴリズム</a>
  <ul class="collapse">
  <li><a href="#実装" id="toc-実装" class="nav-link" data-scroll-target="#実装"><span class="header-section-number">3.3.1</span> 実装</a></li>
  </ul></li>
  <li><a href="#階条件を使う" id="toc-階条件を使う" class="nav-link" data-scroll-target="#階条件を使う"><span class="header-section-number">3.4</span> １階条件を使う</a>
  <ul class="collapse">
  <li><a href="#sec-root-finding" id="toc-sec-root-finding" class="nav-link" data-scroll-target="#sec-root-finding"><span class="header-section-number">3.4.1</span> 非線形方程式の求根問題</a></li>
  <li><a href="#sec-projection" id="toc-sec-projection" class="nav-link" data-scroll-target="#sec-projection"><span class="header-section-number">3.4.2</span> パラメトリックな近似：射影法</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="hidden">
<p><span class="math display">\[
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\abs}[1]{\lvert#1\rvert}
\newcommand{\Abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\|#1\|}
\newcommand{\Norm}[1]{\left\|#1\right\|}
\newcommand{\SquareBrac}[1]{\left[#1\right]}
\newcommand{\Brace}[1]{\left\{#1\right\}}
\newcommand{\Paren}[1]{\left(#1\right)}
\newcommand{\brac}[1]{\langle#1\rangle}
\newcommand{\Brac}[1]{\left\langle#1\right\rangle}
\newcommand{\bra}[1]{\left\langle#1\right|}
\newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\ov}[1]{\overline{#1}}
\newcommand{\un}[1]{\underline{#1}}
\newcommand{\wt}[1]{\widetilde{#1}}
\newcommand{\wh}[1]{\widehat{#1}}
\newcommand{\pp}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\ppp}[3]{\frac{\partial #1}{\partial #2\partial #3}}
\newcommand{\dd}[2]{\frac{d #1}{d #2}}
\newcommand{\floor}[1]{\lfloor#1\rfloor}
\newcommand{\Floor}[1]{\left\lfloor#1\right\rfloor}
\newcommand{\ceil}[1]{\lceil#1\rceil}
\newcommand{\Ceil}[1]{\left\lceil#1\rceil\right}
\newcommand{\iso}{\overset{\sim}{\to}}
\newcommand{\eqDescribe}[2]{\underbrace{#1}_{\text{#2}}}
\newcommand{\bm}[1]{\boldsymbol{#1}}
\newcommand{\argmax}{\operatorname*{argmax}}
\newcommand{\argmin}{\operatorname*{argmin}}
\]</span></p>
</div>
<section id="はじめに" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="はじめに"><span class="header-section-number">1</span> はじめに</h2>
<p>今年の6月に『定量的マクロ経済学と数値計算』という本が出版された <span class="citation" data-cites="QuantMacro2024">(<a href="#ref-QuantMacro2024" role="doc-biblioref">北尾早霧, 砂川武貴, and 山田知明 2024</a>)</span>．</p>
<p>近年マクロ経済学のモデルが複雑になるにつれて，コンピュータを使って近似的にモデルの性質を理解するアプローチが広まっている．</p>
<p>しかし，日本のマクロ経済学教育の中で，それを可能にする<strong>数値計算 (numerical computation)</strong> という分析手法を学ぶ機会は乏しい．</p>
<p>この状況を憂いた著者陣が，<a href="https://note.com/keisemi/n/n435bd35caf93?sub_rt=share_sb">『経済セミナー』</a>という雑誌に投稿した連載を書籍化したのが本書である．</p>
<p>本書が扱う内容は，現代的なマクロ経済学のベースラインとなりつつあるトピックであり，教育が手薄になるのは好ましくない．</p>
<blockquote class="blockquote">
<p>本書が扱う内容は現在のマクロ経済学のメインストリームの１つといっても過言ではない。＜中略＞本書を通じて現代のマクロ経済分析に必要な新たな道具を身に付けるサポートをすることが、我々の目的である。(p.8)</p>
</blockquote>
<p>（気持ちネットワークを扱うモデルをメインにやっているとはいえ，）マクロ経済学徒の一人としては現代的な分析手法を学ぶ必要があると感じたため，勉強ノートを作ろうと思い立った次第である．</p>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>このウェブサイトのフレームワークとなっている <a href="https://quarto.org/">Quarto</a> は，このようなハンズオンで学ぶスタイルの勉強ノート作成に適している． Quarto もまだまだ勉強中の身ゆえ，このブログは Quarto の勉強も兼ねている．</p>
</div>
</div>
</div>
</section>
<section id="ベンチマークモデルとカリブレーション" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="ベンチマークモデルとカリブレーション"><span class="header-section-number">2</span> ベンチマーク・モデルとカリブレーション</h2>
<p>まず，シンプルな２期間モデルを用いて数値計算手法の基本的な使い方のイメージをつかむ．</p>
<p>現在のマクロ経済学でベンチマークとなっている新古典派成長モデルは，この２期間モデルを多期間に拡張していき，その極限をとって無限期間にしたものである．</p>
<p>したがって，まずはこのシンプルな２期間モデルで数値計算の基礎をおさえておくことが重要である．</p>
<section id="ベンチマークモデル２期間モデル" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="ベンチマークモデル２期間モデル"><span class="header-section-number">2.1</span> ベンチマーク・モデル：２期間モデル</h3>
<p>ある経済主体の人生全体での消費・貯蓄行動をモデル化しよう．</p>
<p>経済主体は若年期に働いて所得 <span class="math inline">\(w\)</span> を獲得し，その所得を若年期の消費 <span class="math inline">\(c_1\)</span> に充てるか，それとも老後のための貯蓄 <span class="math inline">\(a\)</span> に残すかを決める問題に直面している．</p>
<p>若年期の予算制約は，</p>
<p><span id="eq-bc-young"><span class="math display">\[
c_1 + a = w
\tag{1}\]</span></span></p>
<p>であり，老年期の予算制約は若年期の貯蓄に金利 <span class="math inline">\(r\)</span> が付き，また遺産動機はないとすると，</p>
<p><span id="eq-bc-old"><span class="math display">\[
c_2 = a(1 + r)
\tag{2}\]</span></span></p>
<p>で与えられる．<span class="math inline">\(\beta &gt; 0\)</span> を<strong>割引因子 (discount factor)</strong> とすると，経済主体の生涯効用は次式で与えられる：</p>
<p><span id="eq-lifetime-utility"><span class="math display">\[
U(c_1, c_2) = u(c_1) + \beta u(c_2).
\tag{3}\]</span></span></p>
<p>右辺第２項だが，主体は若年期に意思決定を行うため，将来の消費 <span class="math inline">\(c_2\)</span> から得られる効用 <span class="math inline">\(u(c_2)\)</span> は割り引かれる．</p>
<p>ここで，効用関数について <span class="math inline">\(u'(c) &gt; 0\)</span> および <span class="math inline">\(u''(c) &lt; 0\)</span> を仮定し，主体は<strong>消費の平準化 (consumption smoothing)</strong> を望むものとする<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>．</p>
<p>以上の設定の下で解くべき意思決定問題は，次のように定式化できる．</p>
<p><span id="eq-problem"><span class="math display">\[
\begin{aligned}
\max_{c_1, c_2, a} &amp; \quad U(c_1, c_2) = u(c_1) + \beta u(c_2) \\
\text{s.t.} &amp; \quad c_1 + a = w, \\
&amp; \quad c_2 = (1+r)a. \\
\end{aligned}
\tag{4}\]</span></span></p>
<p>ラグランジアンは</p>
<p><span class="math display">\[
\mathcal{L} = u(c_1) + \beta u(c_2) + \lambda_1 (w - c_1 - a) + \lambda_2[(1+r)a - c_2]
\]</span></p>
<p>より，一階条件は</p>
<p><span class="math display">\[
\begin{aligned}
&amp;0 = \frac{\partial\mathcal{L}}{\partial c_1} = u'(c_1) - \lambda_1,\\
&amp;0 = \frac{\partial\mathcal{L}}{\partial c_2} = \beta u'(c_2) - \lambda_2,\\
&amp;0 = \frac{\partial\mathcal{L}}{\partial a} = -\lambda_1 + \lambda_2(1+r).
\end{aligned}
\]</span></p>
<p>整理すると <a href="#eq-euler" class="quarto-xref">式&nbsp;5</a> のオイラー条件（オイラー方程式）を得る．</p>
<p><span id="eq-euler"><span class="math display">\[
u'(c_1) = \beta (1+r) u'(c_2).
\tag{5}\]</span></span></p>
<p>オイラー条件（<a href="#eq-euler" class="quarto-xref">式&nbsp;5</a>）の直感的な意味は，若年期と老年期で極端に消費水準が変動することを嫌うリスク回避的な主体は，若年期の消費 <span class="math inline">\(c_1\)</span> から得られる限界効用 <span class="math inline">\(u'(c_1)\)</span> と，老年期の消費 <span class="math inline">\(c_2\)</span> から得られる限界効用の割引現在価値 <span class="math inline">\(\beta (1+r) u'(c_2)\)</span> が一致するように消費計画を決めるということである．</p>
<div class="callout callout-style-simple callout-tip">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>ところで，何をもってモデルを「解いた」と言えるのか．マクロモデルはさまざまな経済変数が登場するため，この点を整理しておかないとすぐに迷子になる．</p>
<p>このモデルの内生変数は <span class="math inline">\(c_1\)</span> と <span class="math inline">\(a\)</span> であり，外生変数は <span class="math inline">\(w\)</span> であるから<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，モデルを解くにはある所得 <span class="math inline">\(w\)</span> のもとでの主体の貯蓄関数 <span class="math inline">\(g(w)\)</span> と消費関数 <span class="math inline">\(h(w)\)</span> を導出すれば良い：</p>
<p><span class="math display">\[
\begin{aligned}
a &amp;= g(w), \\
c_1 &amp;= h(w).
\end{aligned}
\]</span></p>
<p>この例のように，</p>
<p><span class="math display">\[
\text{内生変数} = f(\text{外生変数})
\]</span></p>
<p>と内生変数が外生変数の関数として書けるとき，「モデルが解けた」という．</p>
</div>
</div>
</div>
</section>
<section id="カリブレーション" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="カリブレーション"><span class="header-section-number">2.2</span> カリブレーション</h3>
<p>２期間モデルは人間にとってはシンプルなモデルだが，コンピュータにとってはそうではない．</p>
<p>というのも，効用関数 <span class="math inline">\(u(c)\)</span> という表現は抽象的で，コンピュータには理解できないからである．</p>
<p>そこで，コンピュータが理解できる形で効用関数を「特定化」する必要がある．</p>
<p>ここでは，マクロ経済学で頻繁に使われる<strong>相対的リスク回避度一定 (constant relative risk aversion: CRRA)</strong> 型効用関数を仮定する．</p>
<p><span id="eq-crra"><span class="math display">\[
u(c) = \frac{c^{1-\gamma}}{1-\gamma}.
\tag{6}\]</span></span></p>
<p>リスクが存在するモデルであれば，<span class="math inline">\(\gamma\)</span> は<strong>相対的リスク回避度 (coefficient of relative risk aversion)</strong> であり，同時に<strong>異時点間の代替の弾力性 (intertemporal elasticity of substitution)</strong> の逆数である．</p>
<p><a href="#eq-crra" class="quarto-xref">式&nbsp;6</a> をコンピュータが認識できるように Python で書くと，次のようになる．</p>
<div id="5ff5b11b" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="annotated-cell-1"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-1-1"><a href="#annotated-cell-1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="annotated-cell-1-2"><a href="#annotated-cell-1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-1-3"><a href="#annotated-cell-1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> CRRA(c, gamma):</span>
<span id="annotated-cell-1-4"><a href="#annotated-cell-1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> gamma <span class="op">!=</span> <span class="fl">1.0</span>:</span>
<span id="annotated-cell-1-5"><a href="#annotated-cell-1-5" aria-hidden="true" tabindex="-1"></a>        util <span class="op">=</span> c<span class="op">**</span>(<span class="fl">1.0</span> <span class="op">-</span> gamma) <span class="op">/</span> (<span class="fl">1.0</span> <span class="op">-</span> gamma)</span>
<span id="annotated-cell-1-6"><a href="#annotated-cell-1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-1" data-target-annotation="1">1</button><span id="annotated-cell-1-7" class="code-annotation-target"><a href="#annotated-cell-1-7" aria-hidden="true" tabindex="-1"></a>        util <span class="op">=</span> np.log(c)</span>
<span id="annotated-cell-1-8"><a href="#annotated-cell-1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> util</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-1" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-1" data-code-lines="7" data-code-annotation="1"><span class="math inline">\(\gamma = 1\)</span> の場合に <span class="math inline">\(u(c) = \log c\)</span> としているのは <a href="#eq-crra" class="quarto-xref">式&nbsp;6</a> が <span class="math inline">\(c \to 1\)</span> の極限で発散するため，次式のようにロピタルの定理で解消した結果である．<span class="math display">\[
\begin{aligned}
\lim_{\gamma\to1} u(c)
&amp;= \lim_{\gamma\to1} \frac{c^{1-\gamma}}{1-\gamma} \\
&amp;= \lim_{\gamma\to1} \frac{-c^{1-\gamma} \log c}{-1} \\
&amp;= \lim_{\gamma\to1} c^{1-\gamma}\log c \\
&amp;= \log c
\end{aligned}\]</span></span>
</dd>
</dl>
</div>
</div>
<p>実際にプログラムを動かす際は，関数形の特定に加えて具体的にパラメータの値を決める必要があるが，このように関数形を特定してパラメータを定める一連の作業を<strong>カリブレーション (calibration)</strong> と呼ぶ．</p>
<p>異なる <code>gamma</code> の下で CRRA 型効用関数（<a href="#eq-crra" class="quarto-xref">式&nbsp;6</a>）を可視化したものが <a href="#fig-crra" class="quarto-xref">図&nbsp;1</a> である．</p>
<div id="cell-fig-crra" class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="annotated-cell-2"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-2-1"><a href="#annotated-cell-2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="annotated-cell-2-2"><a href="#annotated-cell-2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-3"><a href="#annotated-cell-2-3" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="annotated-cell-2-4"><a href="#annotated-cell-2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># c の範囲を指定して曲線をプロット</span></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-2" data-target-annotation="1">1</button><span id="annotated-cell-2-5" class="code-annotation-target"><a href="#annotated-cell-2-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> np.linspace(start<span class="op">=</span><span class="fl">0.1</span>, stop<span class="op">=</span><span class="fl">1.0</span>, num<span class="op">=</span><span class="dv">100</span>)</span>
<span id="annotated-cell-2-6"><a href="#annotated-cell-2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-2-7"><a href="#annotated-cell-2-7" aria-hidden="true" tabindex="-1"></a>gammas <span class="op">=</span> [<span class="dv">1</span>, <span class="fl">1.5</span>, <span class="dv">2</span>]</span>
<span id="annotated-cell-2-8"><a href="#annotated-cell-2-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> gamma <span class="kw">in</span> gammas:</span>
<span id="annotated-cell-2-9"><a href="#annotated-cell-2-9" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> CRRA(c, gamma)</span>
<span id="annotated-cell-2-10"><a href="#annotated-cell-2-10" aria-hidden="true" tabindex="-1"></a>    ax.plot(c, u, label<span class="op">=</span><span class="ss">f'gamma = </span><span class="sc">{</span>gamma<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="annotated-cell-2-11"><a href="#annotated-cell-2-11" aria-hidden="true" tabindex="-1"></a>ax.set_title(<span class="st">"Utility Function for Different gamma values"</span>)</span>
<span id="annotated-cell-2-12"><a href="#annotated-cell-2-12" aria-hidden="true" tabindex="-1"></a>ax.set_xlabel(<span class="vs">r"$c$"</span>)</span>
<span id="annotated-cell-2-13"><a href="#annotated-cell-2-13" aria-hidden="true" tabindex="-1"></a>ax.set_ylabel(<span class="vs">r"$u(c)$"</span>)</span>
<span id="annotated-cell-2-14"><a href="#annotated-cell-2-14" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="annotated-cell-2-15"><a href="#annotated-cell-2-15" aria-hidden="true" tabindex="-1"></a>ax.grid()</span>
<span id="annotated-cell-2-16"><a href="#annotated-cell-2-16" aria-hidden="true" tabindex="-1"></a><span class="cf">pass</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-2" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-2" data-code-lines="5" data-code-annotation="1">0.1 から 10 までの値 (0 は定義できないので 0.1 から)</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display">
<div id="fig-crra" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-crra-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="numerical_computation_files/figure-html/fig-crra-output-1.png" width="594" height="448" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-crra-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
図&nbsp;1: CRRA 型効用関数
</figcaption>
</figure>
</div>
</div>
</div>
<p>ベンチマーク・モデルでは人生を 2 期間に分けているので，モデル上の 1 期間を 30 年と想定する． そのため，割引因子 <span class="math inline">\(\beta\)</span> と金利 <span class="math inline">\(r\)</span> は年率ではなく 30 年間の値を使う．</p>
<p>今回は実際に 1 期間を 30 年でカリブレートしている <span class="citation" data-cites="song2012rotten">Song, Storesletten, and Zilibotti (<a href="#ref-song2012rotten" role="doc-biblioref">2012</a>)</span> の値を拝借する．割引因子は年率で <span class="math inline">\(\beta = 0.985\)</span> として，1 期間は 30 年なので 30 乗する（<span class="math inline">\(\beta = 0.985^{30}\)</span>）．金利は年率で <span class="math inline">\(2.5\%\)</span> と設定すると <span class="math inline">\(1+r = 1.025^{30}\)</span> となる．相対的リスク回避度は，よく使われる値の <span class="math inline">\(\gamma = 2\)</span> としておく．</p>
<div id="282159bd" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="fl">0.985</span><span class="op">**</span><span class="dv">30</span>        <span class="co"># 割引因子</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> <span class="fl">2.0</span>             <span class="co"># 相対的危険回避度</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">1.025</span><span class="op">**</span><span class="dv">30</span> <span class="op">-</span> <span class="fl">1.0</span>     <span class="co"># 金利</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="解析解の性質" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="解析解の性質"><span class="header-section-number">2.3</span> 解析解の性質</h3>
<p>数値計算に入る前に，２期間モデルの解析解の性質を簡単に確認しておく．今回のモデルはシンプルなので，貯蓄関数 <span class="math inline">\(a = g(w)\)</span> を手計算で求めることができる．</p>
<p><span id="eq-saving"><span class="math display">\[
% \begin{equation}
a = \frac{w}{1+(1+r)\{\beta(1+r)\}^{-1/\gamma}}
% \end{equation}
\tag{7}\]</span></span></p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
導出
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>オイラー条件（<a href="#eq-euler" class="quarto-xref">式&nbsp;5</a>）に予算制約の <a href="#eq-bc-young" class="quarto-xref">式&nbsp;1</a> と <a href="#eq-bc-old" class="quarto-xref">式&nbsp;2</a> を代入すると，</p>
<p><span class="math display">\[
\begin{aligned}
(w-a)^{-\gamma} &amp;= \beta(1+r)\SquareBrac{(1+r)a}^{-\gamma} \\
(w-a) &amp;= \SquareBrac{\beta(1+r)}^{-1/\gamma}(1+r)a \\
w &amp;= \Brace{1+\SquareBrac{\beta(1+r)}^{-1/\gamma}(1+r)}a.
\end{aligned}
\]</span></p>
</div>
</div>
</div>
<p>これがモデルから導出される真の貯蓄関数であり，内生変数 <span class="math inline">\(a\)</span> が外生変数 <span class="math inline">\(w, r, \beta, \gamma\)</span> で表されているので，これでモデルは解けている．</p>
<p>貯蓄関数（<a href="#eq-saving" class="quarto-xref">式&nbsp;7</a>）は若年期の所得 <span class="math inline">\(w\)</span> の連続な線形の増加関数になっており，そのグラフを可視化したものが <a href="#fig-saving" class="quarto-xref">図&nbsp;2</a> である．</p>
<div id="cell-fig-saving" class="cell" data-execution_count="4">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="annotated-cell-4"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-4" data-target-annotation="1">1</button><span id="annotated-cell-4-1" class="code-annotation-target"><a href="#annotated-cell-4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> japanize_matplotlib</span>
<span id="annotated-cell-4-2"><a href="#annotated-cell-4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-3"><a href="#annotated-cell-4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 傾き</span></span>
<span id="annotated-cell-4-4"><a href="#annotated-cell-4-4" aria-hidden="true" tabindex="-1"></a>slope <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">1</span><span class="op">+</span>r) <span class="op">*</span> (beta<span class="op">*</span>(<span class="dv">1</span><span class="op">+</span>r)) <span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>gamma))</span>
<span id="annotated-cell-4-5"><a href="#annotated-cell-4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-6"><a href="#annotated-cell-4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 貯蓄関数</span></span>
<span id="annotated-cell-4-7"><a href="#annotated-cell-4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> saving(w, beta, r, gamma):</span>
<span id="annotated-cell-4-8"><a href="#annotated-cell-4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> w <span class="op">/</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">1</span><span class="op">+</span>r) <span class="op">*</span> (beta<span class="op">*</span>(<span class="dv">1</span><span class="op">+</span>r)) <span class="op">**</span>(<span class="op">-</span><span class="dv">1</span><span class="op">/</span>gamma))</span>
<span id="annotated-cell-4-9"><a href="#annotated-cell-4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-10"><a href="#annotated-cell-4-10" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="annotated-cell-4-11"><a href="#annotated-cell-4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-4-12"><a href="#annotated-cell-4-12" aria-hidden="true" tabindex="-1"></a>w <span class="op">=</span> np.linspace(start<span class="op">=</span><span class="dv">0</span>, stop<span class="op">=</span><span class="fl">1.0</span>, num<span class="op">=</span><span class="dv">100</span>)</span>
<span id="annotated-cell-4-13"><a href="#annotated-cell-4-13" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> saving(w, beta, r, gamma)</span>
<span id="annotated-cell-4-14"><a href="#annotated-cell-4-14" aria-hidden="true" tabindex="-1"></a>ax.plot(w, a, c<span class="op">=</span><span class="st">"#FF7A72"</span>)</span>
<span id="annotated-cell-4-15"><a href="#annotated-cell-4-15" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"貯蓄関数"</span>, xlabel<span class="op">=</span><span class="st">"若年期の所得: "</span><span class="op">+</span><span class="vs">r"$w$"</span>, ylabel<span class="op">=</span><span class="st">"若年期の貯蓄: "</span><span class="op">+</span><span class="vs">r"$a=g(w)$"</span>, xlim<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">1</span>), ylim<span class="op">=</span>(<span class="dv">0</span>,<span class="fl">0.4</span>))</span>
<span id="annotated-cell-4-16"><a href="#annotated-cell-4-16" aria-hidden="true" tabindex="-1"></a>ax.grid()</span>
<span id="annotated-cell-4-17"><a href="#annotated-cell-4-17" aria-hidden="true" tabindex="-1"></a><span class="cf">pass</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-4" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-4" data-code-lines="1" data-code-annotation="1">タイトルや軸ラベルを日本語で書くときに必要</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display">
<div id="fig-saving" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-saving-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="numerical_computation_files/figure-html/fig-saving-output-1.png" width="610" height="451" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-saving-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
図&nbsp;2: 解析的に求めた貯蓄関数
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="実践数値計算" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="実践数値計算"><span class="header-section-number">3</span> 【実践】数値計算</h2>
<section id="離散近似とグリッド" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="離散近似とグリッド"><span class="header-section-number">3.1</span> 離散近似とグリッド</h3>
<p>貯蓄関数（<a href="#eq-saving" class="quarto-xref">式&nbsp;7</a>）は連続関数であるが，コンピュータは連続という概念をそのままの形では理解できない．</p>
<p>そこで，数値計算においては基本的に，連続な変数を有限の <span class="math inline">\(N\)</span> 個の点に<strong>離散化 (discretize)</strong> して考える必要がある．</p>
<section id="グリッド上で計算する" class="level4" data-number="3.1.1">
<h4 data-number="3.1.1" class="anchored" data-anchor-id="グリッド上で計算する"><span class="header-section-number">3.1.1</span> グリッド上で計算する</h4>
<p>若年期の所得 <span class="math inline">\(w\)</span> がとりうる値は，<span class="math inline">\(w_i \in \{w_1,\ldots,w_N\}\)</span> の範囲にあるとする．</p>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>コンピュータは無限を扱えないので，<span class="math inline">\(w \in [0, \infty)\)</span> や <span class="math inline">\(w \in (-\infty, \infty)\)</span> のような範囲を扱うことはできない． 数値計算において，定義域は必ず<strong>有界 (finite)</strong>である必要がある．</p>
</div>
</div>
</div>
<p>所得を <span class="math inline">\(N\)</span> 個に離散化するということは，若年期の所得に応じて <span class="math inline">\(N\)</span> 種類の経済主体が存在している状況を作り出すということである．</p>
<p>この離散的な点の集まりを<strong>グリッド (grid)</strong> あるいは<strong>ノード (node)</strong> と呼ぶ． また，それぞれの点は<strong>グリッドポイント (grid point)</strong> あるいは<strong>評価点 (evaluation point)</strong> と呼ばれている．</p>
<p>ここでは単純に，若年期の所得 <span class="math inline">\(w\)</span> は <span class="math inline">\([0.1, 1]\)</span> 区間の間に <span class="math inline">\(0.1\)</span> 刻みで <span class="math inline">\(10\)</span> 個の点</p>
<p><span class="math display">\[
w_i \in \{0.1, 0.2,\ldots, 1.0\}
\]</span></p>
<p>として存在していると考える．</p>
<div id="2c6ad8f8" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>nw <span class="op">=</span> <span class="dv">10</span>       <span class="co"># 所得グリッドの数</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>w_min <span class="op">=</span> <span class="fl">0.1</span>   <span class="co"># 所得の最大値</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>w_max <span class="op">=</span> <span class="fl">1.0</span>   <span class="co"># 所得の最小値</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>grid_w <span class="op">=</span> np.linspace(start<span class="op">=</span><span class="fl">0.1</span>, stop<span class="op">=</span><span class="fl">1.0</span>, num<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(grid_w)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]</code></pre>
</div>
</div>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>この意思決定問題では <span class="math inline">\(w_i = 0\)</span> を含めると若年期も老年期も消費ができなくなってしまうため，最小値は正値にしておく必要がある．</p>
</div>
</div>
</div>
</section>
</section>
<section id="sec-grid-search" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="sec-grid-search"><span class="header-section-number">3.2</span> 状態変数と制御変数がともに離散の場合：グリッドサーチ</h3>
<div class="callout callout-style-simple callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
用語の導入
</div>
</div>
<div class="callout-body-container callout-body">
<p>最適化問題を解く際にすでに決まっている若年期の所得 <span class="math inline">\(w\)</span> を<strong>状態変数 (state variable)</strong> と呼び，意思決定において選択する若年期の貯蓄 <span class="math inline">\(a\)</span> を<strong>制御変数 (control variable)</strong> と呼ぶ． また，貯蓄関数のような意思決定関数は<strong>政策関数 (policy function)</strong> と呼ばれる．</p>
</div>
</div>
<p>まずは，所得 <span class="math inline">\(w\)</span> と資産 <span class="math inline">\(a\)</span> がともに離散的な場合に２期間モデルを解く方法を見る．</p>
<p>すなわち，状態変数 <span class="math inline">\(w\)</span> だけでなく，制御変数 <span class="math inline">\(a\)</span> についても離散化を行う．</p>
<p>ここでは</p>
<p><span class="math display">\[
a_j \in \{0.025, 0.05, 0.075, 0.1, \ldots, 1.0\}
\]</span></p>
<p>と <span class="math inline">\(0.025\)</span> 刻みで <span class="math inline">\(40\)</span> 個のグリッドをとる<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>．</p>
<div id="dcecaa69" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>na <span class="op">=</span> <span class="dv">40</span>       <span class="co"># 貯蓄グリッドの数</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>a_min <span class="op">=</span> <span class="fl">0.025</span> <span class="co"># 貯蓄の最小値</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>a_max <span class="op">=</span> <span class="fl">1.0</span>   <span class="co"># 貯蓄の最大値</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>grid_a <span class="op">=</span> np.linspace(start<span class="op">=</span>a_min, stop<span class="op">=</span>a_max, num<span class="op">=</span>na)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(grid_a)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[0.025 0.05  0.075 0.1   0.125 0.15  0.175 0.2   0.225 0.25  0.275 0.3
 0.325 0.35  0.375 0.4   0.425 0.45  0.475 0.5   0.525 0.55  0.575 0.6
 0.625 0.65  0.675 0.7   0.725 0.75  0.775 0.8   0.825 0.85  0.875 0.9
 0.925 0.95  0.975 1.   ]</code></pre>
</div>
</div>
<p>このような離散化を行うと，解くべき効用最大化問題（<a href="#eq-problem" class="quarto-xref">式&nbsp;4</a>）は，所与の <span class="math inline">\(w_i\)</span> について，</p>
<p><span id="eq-obj"><span class="math display">\[
\max_{a_j} \quad
\frac{[w_i-a_j]^{1-\gamma}}{1-\gamma} + \beta\frac{[(1+r)a_j]^{1-\gamma}}{1-\gamma}
\tag{8}\]</span></span></p>
<p>と書き直すことができる．</p>
<p>組み合わせの数は，所得 <span class="math inline">\(w_i\)</span> と資産 <span class="math inline">\(a_j\)</span> がそれぞれ <span class="math inline">\(10\)</span> 通りと <span class="math inline">\(40\)</span> 通りあるので， <span class="math inline">\(400\)</span> 通りとなる．</p>
<p>そして各所得 <span class="math inline">\(w_i\)</span> のもとで <span class="math inline">\(40\)</span> 種類の資産 <span class="math inline">\(a_j\)</span> の中から生涯効用（<a href="#eq-obj" class="quarto-xref">式&nbsp;8</a>）を最大化する資産 <span class="math inline">\(a^*\)</span> を求めれば良いので，これくらいであれば「総当たり」で求めることができる．</p>
<div id="412b5b9b" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="annotated-cell-7"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="1">1</button><span id="annotated-cell-7-1" class="code-annotation-target"><a href="#annotated-cell-7-1" aria-hidden="true" tabindex="-1"></a>obj <span class="op">=</span> np.zeros((na, nw))</span>
<span id="annotated-cell-7-2"><a href="#annotated-cell-7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-7-3"><a href="#annotated-cell-7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 状態変数と制御変数のすべての組み合わせ (w,a) について生涯効用を計算</span></span>
<span id="annotated-cell-7-4"><a href="#annotated-cell-7-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nw):</span>
<span id="annotated-cell-7-5"><a href="#annotated-cell-7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(na):</span>
<span id="annotated-cell-7-6"><a href="#annotated-cell-7-6" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> grid_w[i] <span class="op">-</span> grid_a[j]</span>
<span id="annotated-cell-7-7"><a href="#annotated-cell-7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="annotated-cell-7-8"><a href="#annotated-cell-7-8" aria-hidden="true" tabindex="-1"></a>            obj[j, i] <span class="op">=</span> CRRA(c, gamma) <span class="op">+</span> beta <span class="op">*</span> CRRA((<span class="dv">1</span><span class="op">+</span>r)<span class="op">*</span>grid_a[j], gamma)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-7" data-target-annotation="2">2</button><span id="annotated-cell-7-9" class="code-annotation-target"><a href="#annotated-cell-7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="annotated-cell-7-10"><a href="#annotated-cell-7-10" aria-hidden="true" tabindex="-1"></a>            obj[j, i] <span class="op">=</span> <span class="op">-</span><span class="fl">10000.0</span> </span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-7" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="1" data-code-annotation="1">各 <span class="math inline">\((w_i, a_j)\)</span> での生涯効用を格納する<code>na</code> <span class="math inline">\(\times\)</span> <code>nw</code> ゼロ行列</span>
</dd>
<dt data-target-cell="annotated-cell-7" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-7" data-code-lines="9" data-code-annotation="2">消費が負になる場合，負の効用を与えて最適化でこの値が選ばれないようにしておく</span>
</dd>
</dl>
</div>
</div>
<p>試しに，<code>w = 0.5, 0.8, 1.0</code> のときの生涯効用を可視化してみよう（<a href="#fig-obj" class="quarto-xref">図&nbsp;3</a>）．</p>
<div id="cell-fig-obj" class="cell" data-execution_count="8">
<details class="code-fold">
<summary>Show the code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>ax.plot(grid_a, obj[:,<span class="dv">4</span>], c<span class="op">=</span><span class="st">"b"</span>, label<span class="op">=</span><span class="st">"w=0.5"</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>ax.plot(grid_a, obj[:,<span class="dv">7</span>], c<span class="op">=</span><span class="st">"r"</span>, label<span class="op">=</span><span class="st">"w=0.8"</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>ax.plot(grid_a, obj[:,<span class="dv">9</span>], c<span class="op">=</span><span class="st">"g"</span>, label<span class="op">=</span><span class="st">"w=1.0"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(xlabel<span class="op">=</span><span class="st">"若年期の貯蓄(老年期の資産): "</span><span class="op">+</span><span class="vs">r"$a$"</span>, ylabel<span class="op">=</span><span class="st">"生涯効用: "</span><span class="op">+</span><span class="vs">r"$U(c_1,c_2)$"</span>, xlim<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">1</span>), ylim<span class="op">=</span>(<span class="op">-</span><span class="dv">10</span>,<span class="dv">0</span>))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>ax.grid(ls<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div id="fig-obj" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-obj-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="numerical_computation_files/figure-html/fig-obj-output-1.png" width="606" height="437" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-obj-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
図&nbsp;3: 生涯効用
</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#fig-obj" class="quarto-xref">図&nbsp;3</a> では若年期の所得 <span class="math inline">\(w_i\)</span> の下での生涯効用 <span class="math inline">\(U(a_j; w_i)\)</span> が凹関数として可視化されている．</p>
<p>直感的にそれぞれの山の頂上に対応する貯蓄点が，求めたい最適貯蓄だとわかるだろう．</p>
<p>そこで，若年期の所得 <span class="math inline">\(w_i\)</span> ごとに最適な貯蓄点 <span class="math inline">\(a_j\)</span> を計算し，求めた貯蓄関数を可視化する（<a href="#fig-policy" class="quarto-xref">図&nbsp;4</a>）．</p>
<div id="cell-fig-policy" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="annotated-cell-9"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-9" data-target-annotation="1">1</button><span id="annotated-cell-9-1" class="code-annotation-target"><a href="#annotated-cell-9-1" aria-hidden="true" tabindex="-1"></a>pol <span class="op">=</span> np.zeros(nw)</span>
<span id="annotated-cell-9-2"><a href="#annotated-cell-9-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nw):</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-9" data-target-annotation="2">2</button><span id="annotated-cell-9-3" class="code-annotation-target"><a href="#annotated-cell-9-3" aria-hidden="true" tabindex="-1"></a>    maximizer <span class="op">=</span> np.argmax(obj[:, i])</span>
<span id="annotated-cell-9-4"><a href="#annotated-cell-9-4" aria-hidden="true" tabindex="-1"></a>    pol[i] <span class="op">=</span> grid_a[maximizer]</span>
<span id="annotated-cell-9-5"><a href="#annotated-cell-9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-9-6"><a href="#annotated-cell-9-6" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="annotated-cell-9-7"><a href="#annotated-cell-9-7" aria-hidden="true" tabindex="-1"></a>ax.plot(grid_w, saving(grid_w, beta, r, gamma), c<span class="op">=</span><span class="st">"#FF7A72"</span>,label<span class="op">=</span><span class="st">"解析解"</span>)</span>
<span id="annotated-cell-9-8"><a href="#annotated-cell-9-8" aria-hidden="true" tabindex="-1"></a>ax.plot(grid_w, pol, c<span class="op">=</span><span class="st">"#78C2AD"</span>, marker<span class="op">=</span><span class="st">"o"</span>, label<span class="op">=</span><span class="st">"グリッドサーチ"</span>)</span>
<span id="annotated-cell-9-9"><a href="#annotated-cell-9-9" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"貯蓄関数"</span>, xlabel<span class="op">=</span><span class="st">"若年期の所得: "</span><span class="op">+</span><span class="vs">r"$w$"</span>, ylabel<span class="op">=</span><span class="st">"若年期の貯蓄: "</span><span class="op">+</span><span class="vs">r"$a=g(w)$"</span>)</span>
<span id="annotated-cell-9-10"><a href="#annotated-cell-9-10" aria-hidden="true" tabindex="-1"></a>ax.grid(ls<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="annotated-cell-9-11"><a href="#annotated-cell-9-11" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="annotated-cell-9-12"><a href="#annotated-cell-9-12" aria-hidden="true" tabindex="-1"></a><span class="cf">pass</span></span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-9" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-9" data-code-lines="1" data-code-annotation="1">政策関数（貯蓄関数）を格納するゼロベクトル</span>
</dd>
<dt data-target-cell="annotated-cell-9" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-9" data-code-lines="3" data-code-annotation="2">生涯効用が最大値をとる点を探し，そのインデックスを取得する</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-display">
<div id="fig-policy" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-policy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="numerical_computation_files/figure-html/fig-policy-output-1.png" width="600" height="451" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-policy-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
図&nbsp;4: グリッドサーチで求めた貯蓄関数
</figcaption>
</figure>
</div>
</div>
</div>
<p><a href="#fig-policy" class="quarto-xref">図&nbsp;4</a> を見ると，グリッドサーチで求めた最適貯蓄（緑色の点）が，解析解（赤色の直線）からあまり離れていないことがわかる．</p>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>グリッドサーチのグラフは点同士を直線でつないだ折れ線グラフのように見えるが，これは <code>plot()</code> 関数の仕様によるものである．実際には，状態変数 <span class="math inline">\(w\)</span> のグリッドポイント上でしか最適貯蓄 <span class="math inline">\(a\)</span> を求めていないことに注意されたい．</p>
</div>
</div>
</div>
<p>グリッドサーチで精度を上げるには，離散化するグリッドの数を増やせば良さそうだが，考えているモデルによっては次のセクションで扱う「次元の呪い」という問題にぶつかる．</p>
<section id="注意点次元の呪い" class="level4" data-number="3.2.1">
<h4 data-number="3.2.1" class="anchored" data-anchor-id="注意点次元の呪い"><span class="header-section-number">3.2.1</span> 注意点：次元の呪い</h4>
<p>状態変数と制御変数をどちらも離散化して，とりうる全ての組み合わせを計算するというグリッドサーチのアプローチは，単純ではあるが複雑な非線形モデルにも使えるのでなかなか侮れない．</p>
<p>たとえば，政策関数の形状や性質がよくわかっていないモデルを解く場合，とりあえずグリッドを切ってモデルの性質を大雑把に掴むというアプローチは有効である．</p>
<p>しかし，このアプローチは<strong>次元の呪い (curse of dimensionality)</strong> の影響をダイレクトに受けるので，計算に時間がかかる傾向にある．</p>
<p>状態変数の数が <span class="math inline">\(n\)</span> 個のとき，最適貯蓄を計算する必要のあるグリッドポイントの数は</p>
<p><span class="math display">\[
(\text{状態変数のグリッド数})^n
\]</span></p>
<p>で与えられる．したがって，たとえば教育水準の違いや性別の違いを考慮できるように若年期における状態変数を増やしていくと，計算時間は指数的に増えてしまう．</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
次元の呪い
</div>
</div>
<div class="callout-body-container callout-body">
<p>状態変数を増やせば増やすほど，計算時間は指数的に増える．そのため，現実的な計算時間で複雑なモデルを高い精度で解くための工夫が常に求められる．</p>
</div>
</div>
</section>
<section id="sec-obj-oriented" class="level4" data-number="3.2.2">
<h4 data-number="3.2.2" class="anchored" data-anchor-id="sec-obj-oriented"><span class="header-section-number">3.2.2</span> オブジェクト指向プログラミング</h4>
<p>数値計算では，コンピュータが理解できるように関数を特定化してパラメータを設定するカリブレーションという作業が必要なのであった．</p>
<p>ここまでの実装では，逐一関数を定義してパラメータを指定していた．</p>
<p>しかし，その方法ではパラメータが変わった時にモデルの振る舞いがどう変わるかを分析する比較静学のような場面で苦労しそうなのは容易に想像できる．</p>
<p>そこで，オブジェクト指向プログラミングの<strong>クラス (class)</strong> という機能でモデルのテンプレートを作っておくと便利である．</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="in">class Models:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="in">    def __init__(self, beta, gamma, r, nw, w_min, w_max, grid_w, na, a_min, a_max, grid_a):</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="in">        self.beta = beta</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="in">        self.gamma = gamma</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="in">        self.r = r</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="in">        self.nw = nw</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="in">        self.w_min = w_min</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="in">        self.w_max = w_max</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="in">        self.grid_w = grid_w</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="in">        self.na = na</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="in">        self.a_min = a_min</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="in">        self.a_max = a_max</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="in">        self.grid_a = grid_a</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>カリブレーションを行う際は <code>Models</code> を定義した上で，次の <code>Calibration()</code> 関数を実行する．</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="in">def Calibration():</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="in">    beta = 0.985 ** 30</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="in">    gamma = 2.0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="in">    r = 1.025**30 - 1.0</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="in">    nw = 10</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="in">    w_min = 0.1</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="in">    w_max = 1.0</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="in">    na = 40</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="in">    a_min = 0.025</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="in">    a_max = 1.0</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="in">    grid_w = np.linspace(w_min, w_max, nw)</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="in">    grid_a = np.linspace(a_min, a_max, na)</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="in">    return Models(beta, gamma, r, nw, w_min, w_max, grid_w, na, a_min, a_max, grid_a)</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>このノートでもこれ以降は，クラスを使ってさまざまなパラメータを管理する．</p>
</section>
</section>
<section id="sec-optimize" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="sec-optimize"><span class="header-section-number">3.3</span> 最適化アルゴリズム</h3>
<p>グリッドサーチはモデルを拡張した場合に計算量が指数的に増加するのに加え，グリッド数を節約すると精度が悪化するという問題を抱えていた．</p>
<p>実際，真の貯蓄関数は <a href="#fig-saving" class="quarto-xref">図&nbsp;2</a> のように線形である一方，グリッドサーチで求めた貯蓄関数は <a href="#fig-policy" class="quarto-xref">図&nbsp;4</a> にあるように直線ではない．</p>
<p>そこで，状態変数 <span class="math inline">\(w\)</span> は <a href="#sec-grid-search" class="quarto-xref">§&nbsp;3.2</a> と同様に離散化するが，連続な制御変数 <span class="math inline">\(a\)</span> を許容するより洗練されたアプローチを採用しよう．</p>
<p>グリッドサーチで考えた問題（<a href="#eq-obj" class="quarto-xref">式&nbsp;8</a>）で離散化していた <span class="math inline">\(a_j\)</span> を連続値にするので，今考えている最適化問題は次式で表される．</p>
<p><span id="eq-prob25"><span class="math display">\[
\max_{a\in\R} \quad
\frac{[w_i-a]^{1-\gamma}}{1-\gamma} + \beta\frac{[(1+r)a]^{1-\gamma}}{1-\gamma}
\tag{9}\]</span></span></p>
<p><a href="#eq-prob25" class="quarto-xref">式&nbsp;9</a> のような最適化問題を数値計算で解くには，数値計算ソフトに標準的に実装されている最適化ライブラリを用いれば良い．</p>
<p>大抵は，目的関数とその関数のパラメータを入力として受け取り，目的関数の最大値や最小値を探索する仕様になっている．</p>
<p>最適化問題（<a href="#eq-prob25" class="quarto-xref">式&nbsp;9</a>）であれば，カリブレーションしたパラメータ <span class="math inline">\(\{\beta, \gamma, r\}\)</span> を所与として，各状態変数 <span class="math inline">\(w_i \in \Brace{w_1, \ldots, w_N}\)</span> の下で生涯効用の最大値とそれを与える最大元 <span class="math inline">\(a\)</span> を探索してくれる．</p>
<section id="実装" class="level4" data-number="3.3.1">
<h4 data-number="3.3.1" class="anchored" data-anchor-id="実装"><span class="header-section-number">3.3.1</span> 実装</h4>
<p>まず，カリブレーションを <a href="#sec-obj-oriented" class="quarto-xref">§&nbsp;3.2.2</a> で導入した方法で行う．</p>
<div id="f6bdaa07" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Models:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, beta, gamma, r, nw, w_min, w_max, grid_w):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta <span class="op">=</span> beta</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.gamma <span class="op">=</span> gamma</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.r <span class="op">=</span> r</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.nw <span class="op">=</span> nw</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.w_min <span class="op">=</span> w_min</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.w_max <span class="op">=</span> w_max</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.grid_w <span class="op">=</span> grid_w</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Calibration():</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    beta <span class="op">=</span> <span class="fl">0.985</span> <span class="op">**</span> <span class="dv">30</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    gamma <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    r <span class="op">=</span> <span class="fl">1.025</span><span class="op">**</span><span class="dv">30</span> <span class="op">-</span> <span class="fl">1.0</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    nw <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    w_min <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    w_max <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    grid_w <span class="op">=</span> np.linspace(w_min, w_max, nw)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> Models(beta, gamma, r, nw, w_min, w_max, grid_w)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><code>Calibration()</code> 関数を実行することで，<code>Calibration()</code> 内で定義されたパラメータを情報として持つ <code>Models</code> インスタンスが生成されるので，<code>params</code> に代入しておく．</p>
<div id="ef71f4a5" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>params <span class="op">=</span> Calibration()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>ここでは，<code>scipy</code> の <code>optimize</code> モジュールにある <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fminbound.html#scipy.optimize.fminbound"><code>fminbound()</code> 関数</a>を使って最適化問題（<a href="#eq-prob25" class="quarto-xref">式&nbsp;9</a>）を解く<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>．</p>
<div id="3dc29b1e" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> optimize</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>では，<code>optimize.fminbound()</code> に渡す目的関数を定義しよう．最小化問題に変換するために <span class="math inline">\(-1\)</span> をかけている．</p>
<p><span class="math display">\[
\text{obj}(a, w_i;\beta, \gamma, r) = -\Brace{\frac{[w_i-a]^{1-\gamma}}{1-\gamma} + \beta\frac{[(1+r)a]^{1-\gamma}}{1-\gamma}}
\]</span></p>
<div id="a3c8f0cb" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> obj(a, w_i, params):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> w_i <span class="op">-</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> c <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        life_util <span class="op">=</span> CRRA(c, params.gamma) <span class="op">+</span> params.beta <span class="op">*</span> CRRA((<span class="dv">1</span><span class="op">+</span>params.r)<span class="op">*</span>a, params.gamma)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        life_util <span class="op">=</span> <span class="op">-</span><span class="fl">100000.0</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="fl">1.0</span> <span class="op">*</span> life_util</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-simple callout-important">
<div class="callout-body d-flex">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-body-container">
<p>上の <code>obj()</code> は <code>a, w_i, params</code> の３つの引数を持つが，実際に <code>optimize.fminbound()</code> に渡すときは，最適化を行う <code>a</code> だけの関数にしておく必要がある．</p>
</div>
</div>
</div>
<p>所与の状態変数 <span class="math inline">\(w_i\)</span> に対して制御変数 <span class="math inline">\(a\)</span> についての最適化問題を解けば良いので，<code>grid_w</code> についての <code>for</code> ループ内で <code>optimize.fminbound()</code> を使えば良い．</p>
<div id="8eead241" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="annotated-cell-16"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-16" data-target-annotation="1">1</button><span id="annotated-cell-16-1" class="code-annotation-target"><a href="#annotated-cell-16-1" aria-hidden="true" tabindex="-1"></a>opt_a <span class="op">=</span> np.zeros(params.nw)</span>
<span id="annotated-cell-16-2"><a href="#annotated-cell-16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-16-3"><a href="#annotated-cell-16-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, w_i <span class="kw">in</span> <span class="bu">enumerate</span>(params.grid_w):</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-16" data-target-annotation="2">2</button><span id="annotated-cell-16-4" class="code-annotation-target"><a href="#annotated-cell-16-4" aria-hidden="true" tabindex="-1"></a>    obj_specified <span class="op">=</span> <span class="kw">lambda</span> a: obj(a, w_i, params)</span>
<span id="annotated-cell-16-5"><a href="#annotated-cell-16-5" aria-hidden="true" tabindex="-1"></a>    opt_a[i] <span class="op">=</span> optimize.fminbound(obj_specified, w_i<span class="op">*</span><span class="fl">0.01</span>, w_i<span class="op">*</span><span class="fl">2.0</span>)</span>
<span id="annotated-cell-16-6"><a href="#annotated-cell-16-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"最適貯蓄の配列: </span><span class="ch">\n</span><span class="sc">{</span>opt_a<span class="sc">}</span><span class="ss">"</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-16" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-16" data-code-lines="1" data-code-annotation="1">各 <span class="math inline">\(w_i\)</span> の下での最適貯蓄を格納する配列</span>
</dd>
<dt data-target-cell="annotated-cell-16" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-16" data-code-lines="4" data-code-annotation="2"><code>optimize.fminbound()</code> に渡すために，<code>obj()</code> を <code>a</code> だけの関数にする</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>最適貯蓄の配列: 
[0.03550017 0.07100034 0.10650385 0.14200403 0.17750421 0.21300505
 0.24850589 0.28400673 0.31950757 0.35500841]</code></pre>
</div>
</div>
<p><code>opt_a</code> には <code>grid_w</code> の各 <span class="math inline">\(w_i\)</span> に対する最適貯蓄 <span class="math inline">\(a\)</span> が格納してある．これを可視化したものが <a href="#fig-optimization" class="quarto-xref">図&nbsp;5</a> である．</p>
<div id="cell-fig-optimization" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>ax.grid(ls<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>ax.scatter(params.grid_w, saving(params.grid_w, params.beta, params.r, params.gamma), c<span class="op">=</span><span class="st">"#FF7A72"</span>,label<span class="op">=</span><span class="st">"解析解"</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>ax.plot(params.grid_w, opt_a, c<span class="op">=</span><span class="st">"#78C2AD"</span>,label<span class="op">=</span><span class="st">"アルゴリズム"</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"貯蓄関数"</span>, xlabel<span class="op">=</span><span class="st">"若年期の所得: "</span><span class="op">+</span><span class="vs">r"$w$"</span>, ylabel<span class="op">=</span><span class="st">"若年期の貯蓄: "</span><span class="op">+</span><span class="vs">r"$a=g(w)$"</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-optimization" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-optimization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="numerical_computation_files/figure-html/fig-optimization-output-1.png" width="600" height="451" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-optimization-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
図&nbsp;5: 最適化アルゴリズムから導出した貯蓄関数
</figcaption>
</figure>
</div>
</div>
</div>
<p>同じグリッドポイントを使っているが，グリッドサーチで求めた <a href="#fig-policy" class="quarto-xref">図&nbsp;4</a> と違って，最適化アルゴリズムで導出した <a href="#fig-optimization" class="quarto-xref">図&nbsp;5</a> は解析的な解（<a href="#fig-saving" class="quarto-xref">図&nbsp;2</a>）が示す綺麗な直線になっており，計算精度が大幅に改善された様子がわかる<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>．</p>
<p>これは制御変数 <span class="math inline">\(a\)</span> がとりうる値を連続値にしたことに起因する．</p>
</section>
</section>
<section id="階条件を使う" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="階条件を使う"><span class="header-section-number">3.4</span> １階条件を使う</h3>
<p>モデルの解が満たすべきオイラー条件（<a href="#eq-euler" class="quarto-xref">式&nbsp;5</a>）をうまく使って数値計算を行うアプローチもある．</p>
<p>ここでは，オイラー条件を求根問題に落とし込んで解く方法（<a href="#sec-root-finding" class="quarto-xref">§&nbsp;3.4.1</a>）と，政策関数自体をパラメトリックに近似する方法（<a href="#sec-projection" class="quarto-xref">§&nbsp;3.4.2</a>）を扱う．</p>
<section id="sec-root-finding" class="level4" data-number="3.4.1">
<h4 data-number="3.4.1" class="anchored" data-anchor-id="sec-root-finding"><span class="header-section-number">3.4.1</span> 非線形方程式の求根問題</h4>
<p>オイラー条件（<a href="#eq-euler" class="quarto-xref">式&nbsp;5</a>）に予算制約を代入すると次式を得る．</p>
<p><span id="eq-2.7"><span class="math display">\[
u'(w-a) = \beta(1+r)u'((1+r)a)
\tag{10}\]</span></span></p>
<p>状態変数 <span class="math inline">\(w\)</span> を <span class="math inline">\(w_i\)</span> と離散化して，それぞれの変数の役割を見てみると</p>
<p><span class="math display">\[
u'(\eqDescribe{w_i}{given} - \eqDescribe{a}{control}) =
\eqDescribe{\beta(1+r)}{parameter}u'(\eqDescribe{(1+r)}{parameter}\ \eqDescribe{a}{control})
\]</span></p>
<p>なので，未知変数は <span class="math inline">\(a\)</span> だけである．そこで，<a href="#eq-2.7" class="quarto-xref">式&nbsp;10</a> を変形して次式で<strong>残差関数 (residual function)</strong> を定義する：</p>
<p><span id="eq-resid"><span class="math display">\[
R(a;w_i) \equiv
\beta(1+r)\frac{u'((1+r)a)}{u'(w_i-a)} - 1.
\tag{11}\]</span></span></p>
<p><a href="#eq-resid" class="quarto-xref">式&nbsp;11</a> を使うと，オイラー条件を満たす制御変数 <span class="math inline">\(a\)</span> を見つける問題を，</p>
<p><span class="math display">\[
R(a;w_i) = 0
\]</span></p>
<p>となる <span class="math inline">\(a\)</span> を探すという<strong>求根（ゼロ点）問題 (root-finding problem)</strong> に変換することができる．</p>
<p>一般に，オイラー条件を変換して得た残差関数（<a href="#eq-resid" class="quarto-xref">式&nbsp;11</a>）は，複雑な形をした非線形方程式である可能性があるが，非線形方程式のゼロ点を探すアルゴリズムの研究は長い歴史を持つため，様々なアプローチが考案されている．</p>
<section id="実装-1" class="level5" data-number="3.4.1.1">
<h5 data-number="3.4.1.1" class="anchored" data-anchor-id="実装-1"><span class="header-section-number">3.4.1.1</span> 実装</h5>
<p>求根問題は <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve"><code>scipy.optimize.fsolve()</code> 関数</a>で解くことができる． ここではカリブレーションは <a href="#sec-optimize" class="quarto-xref">§&nbsp;3.3</a> のものを再び使用する．</p>
<p>まずはソルバーに渡す残差関数（<a href="#eq-resid" class="quarto-xref">式&nbsp;11</a>）を実装しよう．残差関数内にある限界効用 (marginal utility) は</p>
<p><span class="math display">\[
u'(c) = c^{-\gamma}
\]</span></p>
<p>で与えられるので，Python で表すと次のようになる．</p>
<div id="6f62bf3e" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> marginal_util(c, gamma):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c <span class="op">**</span> (<span class="op">-</span> gamma)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>これを用いると残差関数は次のように実装できる．</p>
<div id="73ddaa1c" class="cell" data-execution_count="17">
<div id="lst-resid" class="python cell-code listing quarto-float quarto-figure quarto-figure-left anchored">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-resid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Code&nbsp;1: 残差関数
</figcaption>
<div aria-describedby="lst-resid-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode cell-code" id="lst-resid"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="lst-resid-1"><a href="#lst-resid-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> resid(a, w_i, params):</span>
<span id="lst-resid-2"><a href="#lst-resid-2" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> w_i <span class="op">-</span> a</span>
<span id="lst-resid-3"><a href="#lst-resid-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> c <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="lst-resid-4"><a href="#lst-resid-4" aria-hidden="true" tabindex="-1"></a>        mu_y <span class="op">=</span> marginal_util(c, params.gamma)              <span class="co"># 若年期の限界効用</span></span>
<span id="lst-resid-5"><a href="#lst-resid-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="lst-resid-6"><a href="#lst-resid-6" aria-hidden="true" tabindex="-1"></a>        mu_y <span class="op">=</span> <span class="fl">10000.0</span></span>
<span id="lst-resid-7"><a href="#lst-resid-7" aria-hidden="true" tabindex="-1"></a>    mu_o <span class="op">=</span> marginal_util((<span class="dv">1</span><span class="op">+</span>params.r)<span class="op">*</span>a, params.gamma)     <span class="co"># 老年期の限界効用</span></span>
<span id="lst-resid-8"><a href="#lst-resid-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> params.beta <span class="op">*</span> (<span class="dv">1</span><span class="op">+</span>params.r) <span class="op">*</span> (mu_o<span class="op">/</span>mu_y) <span class="op">-</span> <span class="fl">1.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
</div>
<p><a href="#sec-optimize" class="quarto-xref">§&nbsp;3.3</a> と同様に，ソルバーを使って各状態変数 <span class="math inline">\(w_i\)</span> の下で最適貯蓄を求めていく．</p>
<div id="04d9dae6" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="annotated-cell-19"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><button class="code-annotation-anchor" data-target-cell="annotated-cell-19" data-target-annotation="1">1</button><span id="annotated-cell-19-1" class="code-annotation-target"><a href="#annotated-cell-19-1" aria-hidden="true" tabindex="-1"></a>opt_a <span class="op">=</span> np.zeros(params.nw)</span>
<span id="annotated-cell-19-2"><a href="#annotated-cell-19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-19-3"><a href="#annotated-cell-19-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, w_i <span class="kw">in</span> <span class="bu">enumerate</span>(params.grid_w):</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-19" data-target-annotation="2">2</button><span id="annotated-cell-19-4" class="code-annotation-target"><a href="#annotated-cell-19-4" aria-hidden="true" tabindex="-1"></a>    resid_specified <span class="op">=</span> <span class="kw">lambda</span> a: resid(a, w_i, params)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-19" data-target-annotation="3">3</button><span id="annotated-cell-19-5" class="code-annotation-target"><a href="#annotated-cell-19-5" aria-hidden="true" tabindex="-1"></a>    opt_a[i] <span class="op">=</span> optimize.fsolve(resid_specified, x0<span class="op">=</span><span class="fl">0.01</span>)[<span class="dv">0</span>]</span>
<span id="annotated-cell-19-6"><a href="#annotated-cell-19-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"最適貯蓄の配列: </span><span class="ch">\n</span><span class="sc">{</span>opt_a<span class="sc">}</span><span class="ss">"</span>)</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-19" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-19" data-code-lines="1" data-code-annotation="1">各 <span class="math inline">\(w_i\)</span> の下での最適貯蓄を格納する配列</span>
</dd>
<dt data-target-cell="annotated-cell-19" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-19" data-code-lines="4" data-code-annotation="2"><code>optimize.fsolve()</code> に渡すために，<code>resid()</code> を <code>a</code> だけの関数にする</span>
</dd>
<dt data-target-cell="annotated-cell-19" data-target-annotation="3">3</dt>
<dd>
<span data-code-cell="annotated-cell-19" data-code-lines="5" data-code-annotation="3">我々が欲しい最適な <span class="math inline">\(a\)</span> は <code>optimize.fsolve()</code> の返り値の最初の要素に格納されている</span>
</dd>
</dl>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>最適貯蓄の配列: 
[0.03550089 0.07100178 0.10650266 0.14200355 0.17750444 0.21300533
 0.24850621 0.2840071  0.31950799 0.35500888]</code></pre>
</div>
</div>
<p>結果を図示した <a href="#fig-root-finding" class="quarto-xref">図&nbsp;6</a> を見ると，アルゴリズムで求めた解が解析解の直線上に乗っている様子がわかる．</p>
<div id="cell-fig-root-finding" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>ax.grid(ls<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>ax.plot(params.grid_w, saving(params.grid_w, params.beta, params.r, params.gamma), c<span class="op">=</span><span class="st">"#FF7A72"</span>,label<span class="op">=</span><span class="st">"解析解"</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>ax.scatter(params.grid_w, opt_a, c<span class="op">=</span><span class="st">"#78C2AD"</span>, label<span class="op">=</span><span class="st">"アルゴリズム"</span>)</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"貯蓄関数"</span>, xlabel<span class="op">=</span><span class="st">"若年期の所得: "</span><span class="op">+</span><span class="vs">r"$w$"</span>, ylabel<span class="op">=</span><span class="st">"若年期の貯蓄: "</span><span class="op">+</span><span class="vs">r"$a=g(w)$"</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-root-finding" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-root-finding-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="numerical_computation_files/figure-html/fig-root-finding-output-1.png" width="600" height="451" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-root-finding-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
図&nbsp;6: 求根アルゴリズムから導出した貯蓄関数
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-projection" class="level4" data-number="3.4.2">
<h4 data-number="3.4.2" class="anchored" data-anchor-id="sec-projection"><span class="header-section-number">3.4.2</span> パラメトリックな近似：射影法</h4>
<p>最適化（<a href="#sec-optimize" class="quarto-xref">§&nbsp;3.3</a>）と求根アルゴリズム（<a href="#sec-root-finding" class="quarto-xref">§&nbsp;3.4.1</a>）を使った手法はどちらも，本来連続値をとる現在の所得水準 <span class="math inline">\(w\)</span> を有限個に離散化して，そのグリッドポイント上で最適貯蓄を計算するという点は共通している．</p>
<p>これに対して，<strong>射影法 (projection method)</strong> では求めたい政策関数そのものをパラメトリックに近似するというアプローチをとる<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>．</p>
<p>今考えている政策関数は若年期の所得 <span class="math inline">\(w\)</span> を変数にとる貯蓄関数 <span class="math inline">\(a=g(w)\)</span> である．貯蓄関数をパラメトリックに近似するとは、貯蓄関数を<strong>基底関数 (basis function) </strong> <span class="math inline">\(\{\Psi_m\}_{m=0}^M\)</span> の線形結合 <span class="math inline">\(\hat{g}(w;\bm{\theta})\)</span> で近似するということである<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>．</p>
<p><span id="eq-parametric-approx"><span class="math display">\[
a = g(w) \approx \hat{g}(w;\bm{\theta}) = \sum_{m=0}^M \theta_m\Psi_m(w)
\tag{12}\]</span></span></p>
<p>ここで <span class="math inline">\(\bm{\theta} \equiv \Paren{\theta_m}_{m=0}^M\)</span> は未知の <span class="math inline">\(M+1\)</span> 次元係数ベクトルであり，推定する対象である．</p>
<p>この段階では，未知の貯蓄関数 <span class="math inline">\(g(w)\)</span> はきっとパラメトリックな関数 <span class="math inline">\(\hat{g}(w;\bm{\theta})\)</span> で表されるだろうと思っているに過ぎず，何も解決していない．</p>
<p>しかし，真の貯蓄関数 <span class="math inline">\(g(w)\)</span> はオイラー条件（<a href="#eq-2.7" class="quarto-xref">式&nbsp;10</a>）を満たすので，それを近似した関数 <span class="math inline">\(\hat{g}(w;\bm{\theta})\)</span> もできるだけオイラー条件を満たしておいて欲しいと思うのは自然な要請である．</p>
<p>つまり射影法とは，オイラー条件を満たす政策関数を探す問題を，近似関数 <span class="math inline">\(\hat{g}(w;\bm{\theta})\)</span> ができるだけオイラー条件を満たすように係数ベクトル <span class="math inline">\(\bm{\theta}\)</span> を決める問題に置き換える手法である．</p>
<p>以下では基底関数を <span class="math inline">\(\Psi_m(w) = w^m\)</span> と指定し，貯蓄関数を次の<strong>多項式 (polynomial)</strong> で近似して議論を進める．</p>
<p><span id="eq-2.9"><span class="math display">\[
a \approx \hat{g}(w;\bm{\theta}) = \sum_{m=0}^M \theta_m w^m
\tag{13}\]</span></span></p>
<p>ところで，上述の「できるだけオイラー条件を満たす」ことをどうやって評価すれば良いだろうか．ここで，<a href="#sec-root-finding" class="quarto-xref">§&nbsp;3.4.1</a> で定義した残差関数（<a href="#eq-resid" class="quarto-xref">式&nbsp;11</a>）を思い出そう．</p>
<p>仮に近似関数 <span class="math inline">\(\hat{g}(w;\bm{\theta})\)</span> が真の貯蓄関数 <span class="math inline">\(g(w)\)</span> と完全に一致する場合は残差はゼロになり，うまく近似しているのであれば残差はゼロに近いはずである．つまり，</p>
<p><span id="eq-resid-projection"><span class="math display">\[
R(\bm{\theta}; w) \equiv
\beta (1+r)\frac{u'((1+r)\hat{g}(w;\bm{\theta}))}{u'(w-\hat{g}(w;\bm{\theta}))} - 1 \approx 0
\tag{14}\]</span></span></p>
<p>が「あらゆる <span class="math inline">\(w\)</span> で」成り立つ．</p>
<p>「」をつけたのは，実際に数値計算を行う際コンピュータは連続的な <span class="math inline">\(w\)</span> を扱えないため，任意にとった評価点 <span class="math inline">\(\{w_i\}_{i=1}^N\)</span> 上での残差がゼロに限りなく近くなるようなベクトル <span class="math inline">\(\bm{\theta}\)</span> を見つける必要があるからである．</p>
<p>要素に評価点 <span class="math inline">\(w_i\)</span> 上での残差 <span class="math inline">\(R(\bm{\theta}; w_i)\)</span> を持つベクトルを <span class="math inline">\(\bm{R}(\bm{w}; \bm{\theta}) \equiv \Paren{R(\bm{\theta}; w_i)}_{i=1}^N\)</span> とする． ただし，<span class="math inline">\(\bm{w} = \Paren{w_i}_{i=1}^N\)</span> である．</p>
<p><span class="math inline">\(\rho(\cdot, \cdot)\)</span> を<strong>距離関数 (metric function)</strong> とすると，考えている問題は</p>
<p><span id="eq-2.10"><span class="math display">\[
\bm{\theta}^* = \argmin_\bm{\theta} \rho(\bm{R}(\bm{w}; \bm{\theta}), \bm{0})
\tag{15}\]</span></span></p>
<p>と定式化できる．このように，評価点上でのみ距離を測る方法を<strong>選点法 (collocation method) </strong>と呼ぶ．</p>
<section id="実装-2" class="level5" data-number="3.4.2.1">
<h5 data-number="3.4.2.1" class="anchored" data-anchor-id="実装-2"><span class="header-section-number">3.4.2.1</span> 実装</h5>
<p>カリブレーションは <a href="#sec-optimize" class="quarto-xref">§&nbsp;3.3</a> のものを再び使用する．</p>
<p>ここでは多項式 <a href="#eq-2.9" class="quarto-xref">式&nbsp;13</a> の次数を <span class="math inline">\(M=1\)</span> として，１次関数 <span class="math inline">\(\hat{g}(w;\bm{\theta}) = \theta_0 + \theta_1 w\)</span> で政策関数を近似しよう．</p>
<p>各評価点 <span class="math inline">\(w_i\)</span> での近似値 <span class="math inline">\(\hat{g}(w_i; \bm{\theta})\)</span> を要素にもつ列ベクトルを <span class="math inline">\(\widehat{\bm{g}}\)</span> とすると</p>
<p><span class="math display">\[
\widehat{\bm{g}} = \Paren{\hat{g}(w_i;\bm{\theta})}_{i=1}^N =
\begin{pmatrix} \theta_0 + \theta_1 w_1 \\ \vdots \\ \theta_0 + \theta_1 w_i \\ \vdots \\ \theta_0 + \theta_1 w_N \end{pmatrix} =
\eqDescribe{\begin{pmatrix} 1 &amp; w_1 \\ \vdots &amp; \vdots \\ 1 &amp; w_i \\ \vdots &amp; \vdots \\ 1 &amp; w_N \end{pmatrix}}{denoted by X below}
\begin{pmatrix} \theta_0 \\ \theta_1 \end{pmatrix}
\]</span></p>
<p>と書けるが，これを実装すると次のようになる．</p>
<div id="d3782d85" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="annotated-cell-21"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-21-1"><a href="#annotated-cell-21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> approx_g(theta: np.ndarray, w: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="annotated-cell-21-2"><a href="#annotated-cell-21-2" aria-hidden="true" tabindex="-1"></a>    dim <span class="op">=</span> <span class="bu">len</span>(theta)</span>
<span id="annotated-cell-21-3"><a href="#annotated-cell-21-3" aria-hidden="true" tabindex="-1"></a>    nw <span class="op">=</span> <span class="bu">len</span>(w)</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-21" data-target-annotation="1">1</button><span id="annotated-cell-21-4" class="code-annotation-target"><a href="#annotated-cell-21-4" aria-hidden="true" tabindex="-1"></a>    X <span class="op">=</span> np.zeros((nw, dim))</span>
<span id="annotated-cell-21-5"><a href="#annotated-cell-21-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(dim):</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-21" data-target-annotation="2">2</button><span id="annotated-cell-21-6" class="code-annotation-target"><a href="#annotated-cell-21-6" aria-hidden="true" tabindex="-1"></a>        X[:, j] <span class="op">=</span> w <span class="op">**</span> j</span>
<span id="annotated-cell-21-7"><a href="#annotated-cell-21-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> X <span class="op">@</span> theta</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-21" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-21" data-code-lines="4" data-code-annotation="1">行列 <span class="math inline">\(X\)</span> を初期化</span>
</dd>
<dt data-target-cell="annotated-cell-21" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-21" data-code-lines="6" data-code-annotation="2">行列 <span class="math inline">\(X\)</span> を作成</span>
</dd>
</dl>
</div>
</div>
<p>次に，残差関数 <code>resid()</code>（<a href="#lst-resid" class="quarto-xref">Code&nbsp;1</a>）を利用して，<a href="#eq-resid-projection" class="quarto-xref">式&nbsp;14</a> に従って残差ベクトル <span class="math inline">\(\bm{R}(\bm{w}; \bm{\theta})\)</span> を実装する．</p>
<div id="db0219f6" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="annotated-cell-22"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-22-1"><a href="#annotated-cell-22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> resid_vec(theta, params):</span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-22" data-target-annotation="1">1</button><span id="annotated-cell-22-2" class="code-annotation-target"><a href="#annotated-cell-22-2" aria-hidden="true" tabindex="-1"></a>    g_hats <span class="op">=</span> approx_g(theta, params.grid_w)</span>
<span id="annotated-cell-22-3"><a href="#annotated-cell-22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-22-4"><a href="#annotated-cell-22-4" aria-hidden="true" tabindex="-1"></a>    R <span class="op">=</span> np.zeros(nw)</span>
<span id="annotated-cell-22-5"><a href="#annotated-cell-22-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> g, w_i, i <span class="kw">in</span> <span class="bu">zip</span>(g_hats, params.grid_w, np.arange(nw)):</span>
<span id="annotated-cell-22-6"><a href="#annotated-cell-22-6" aria-hidden="true" tabindex="-1"></a>        R[i] <span class="op">=</span> resid(g, w_i, params)</span>
<span id="annotated-cell-22-7"><a href="#annotated-cell-22-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> R</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-22" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-22" data-code-lines="2" data-code-annotation="1">貯蓄の近似値ベクトル <span class="math inline">\(\bm{\hat{g}}\)</span> を計算</span>
</dd>
</dl>
</div>
</div>
<p>ここで，距離関数 <span class="math inline">\(\rho\)</span> にユークリッド距離を採用すると，考えている問題（<a href="#eq-2.10" class="quarto-xref">式&nbsp;15</a>）は残差二乗和を最小にする <span class="math inline">\(\bm{\theta}\)</span> を見つける非線形最小二乗法に帰着する．</p>
<p>非線形最小二乗法は <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.least_squares.html"><code>scipy.optimize.least_squares()</code></a> で実装することができる．<code>fun</code> 引数に残差ベクトルを計算する関数を渡せば良い．</p>
<div id="2cb68b8d" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="annotated-cell-23"><pre class="sourceCode python code-annotation-code code-with-copy code-annotated"><code class="sourceCode python"><span id="annotated-cell-23-1"><a href="#annotated-cell-23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> projection(params, initial_guess<span class="op">=</span>[<span class="fl">0.1</span>, <span class="fl">0.35</span>]):</span>
<span id="annotated-cell-23-2"><a href="#annotated-cell-23-2" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-23" data-target-annotation="1">1</button><span id="annotated-cell-23-3" class="code-annotation-target"><a href="#annotated-cell-23-3" aria-hidden="true" tabindex="-1"></a>    resid_specified <span class="op">=</span> <span class="kw">lambda</span> theta: resid_vec(theta, params)</span>
<span id="annotated-cell-23-4"><a href="#annotated-cell-23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="annotated-cell-23-5"><a href="#annotated-cell-23-5" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> optimize.least_squares(fun<span class="op">=</span>resid_specified, x0<span class="op">=</span>initial_guess, method<span class="op">=</span><span class="st">"lm"</span>)</span>
<span id="annotated-cell-23-6"><a href="#annotated-cell-23-6" aria-hidden="true" tabindex="-1"></a></span>
<button class="code-annotation-anchor" data-target-cell="annotated-cell-23" data-target-annotation="2">2</button><span id="annotated-cell-23-7" class="code-annotation-target"><a href="#annotated-cell-23-7" aria-hidden="true" tabindex="-1"></a>    estimate_g <span class="op">=</span> approx_g(result.x, params.grid_w)</span>
<span id="annotated-cell-23-8"><a href="#annotated-cell-23-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result.x, result.success, estimate_g</span><div class="code-annotation-gutter-bg"></div><div class="code-annotation-gutter"></div></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-annotation">
<dl class="code-annotation-container-hidden code-annotation-container-grid">
<dt data-target-cell="annotated-cell-23" data-target-annotation="1">1</dt>
<dd>
<span data-code-cell="annotated-cell-23" data-code-lines="3" data-code-annotation="1"><code>optimize.least_squares()</code> に渡すために，<code>resid_vec()</code> を <code>theta</code> だけの関数にする</span>
</dd>
<dt data-target-cell="annotated-cell-23" data-target-annotation="2">2</dt>
<dd>
<span data-code-cell="annotated-cell-23" data-code-lines="7" data-code-annotation="2">推定された <span class="math inline">\(\widehat{\bm{\theta}}\)</span> の下での近似関数 <span class="math inline">\(\hat{g}(w; \widehat{\bm{\theta}})\)</span> を求める</span>
</dd>
</dl>
</div>
</div>
<p>では，実装した <code>projection()</code> 関数を使って射影法を実際に行おう．</p>
<div id="c7e8b304" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> projection(params)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"convergence: </span><span class="sc">{</span>result[<span class="dv">1</span>]<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"The estimated parameter: </span><span class="sc">{</span>result[<span class="dv">0</span>]<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>convergence: True
The estimated parameter: [-1.90171907e-10  3.55008878e-01]</code></pre>
</div>
</div>
<p>解析解（<a href="#eq-saving" class="quarto-xref">式&nbsp;7</a>）によれば，切片はゼロで，傾きは <span class="math inline">\(1/1+(1+r)\{\beta(1+r)\}^{-1/\gamma}\)</span> から計算すると 0.355 であるから，非常に精度良く近似することができている．</p>
<p>推定されたパラメータ <span class="math inline">\(\widehat{\bm{\theta}}\)</span> の下での近似関数のグリッド <span class="math inline">\(\widehat{\bm{g}}(\bm{w}; \widehat{\bm{\theta}})\)</span> と真の貯蓄関数を可視化したものが <a href="#fig-projection" class="quarto-xref">図&nbsp;7</a> である．</p>
<div id="cell-fig-projection" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>ax.grid(ls<span class="op">=</span><span class="st">"--"</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>ax.plot(params.grid_w, saving(params.grid_w, params.beta, params.r, params.gamma), c<span class="op">=</span><span class="st">"#FF7A72"</span>,label<span class="op">=</span><span class="st">"解析解"</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>ax.scatter(params.grid_w, result[<span class="dv">2</span>], c<span class="op">=</span><span class="st">"#78C2AD"</span>, label<span class="op">=</span><span class="st">"射影法"</span>)</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>ax.<span class="bu">set</span>(title<span class="op">=</span><span class="st">"貯蓄関数"</span>, xlabel<span class="op">=</span><span class="st">"若年期の所得: "</span><span class="op">+</span><span class="vs">r"$w$"</span>, ylabel<span class="op">=</span><span class="st">"若年期の貯蓄: "</span><span class="op">+</span><span class="vs">r"$a=g(w)$"</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>ax.legend()</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="cf">pass</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div id="fig-projection" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-projection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="numerical_computation_files/figure-html/fig-projection-output-1.png" width="600" height="451" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-projection-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
図&nbsp;7: 射影法でパラメトリックに近似した貯蓄関数
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
</section>
<section id="references" class="level2 unnumbered">




</section>


<a onclick="window.scrollTo(0, 0); return false;" role="button" id="quarto-back-to-top"><i class="bi bi-arrow-up"></i> Back to top</a><div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-song2012rotten" class="csl-entry" role="listitem">
Song, Zheng, Kjetil Storesletten, and Fabrizio Zilibotti. 2012. <span>“Rotten Parents and Disciplined Children: A Politico-Economic Theory of Public Expenditure and Debt.”</span> <em>Econometrica</em> 80 (6): 2785–2803.
</div>
<div id="ref-QuantMacro2024" class="csl-entry" role="listitem">
北尾早霧, 砂川武貴, and 山田知明. 2024. <em>定量的マクロ経済学と数値計算</em>. 日本評論社.
</div>
<div id="ref-Math4Econ1996" class="csl-entry" role="listitem">
神谷和也, and 浦井憲. 1996. <em>経済学のための数学入門</em>. 東京大学出版会.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>効用関数が凹関数であるとき，経済主体はリスク回避的である．<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>経済学では，方程式の解として決まる変数を<strong>内生変数 (endogenous variable)</strong>，方程式を解く前に値がすでに決まっている変数を<strong>外生変数 (exogenous variable)</strong> と呼ぶ<span class="citation" data-cites="Math4Econ1996">(<a href="#ref-Math4Econ1996" role="doc-biblioref">神谷和也 and 浦井憲 1996</a>)</span>．外生変数は単にパラメータとか状態変数とも言われる．<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p><span class="math inline">\(w_i\)</span> と同じ離散化をすると，<span class="math inline">\(w = 0.1\)</span> のときに　1 期目の消費 <span class="math inline">\(c_1 = w - a\)</span> がゼロか負値しかとれず，最適貯蓄あるいは最適消費が存在しなくなってしまうため．<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><code>fminbound()</code> のように数値計算によって方程式を解くアルゴリズムのことを<strong>ソルバー (solver)</strong> と呼ぶ．<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a href="#fig-optimization" class="quarto-xref">図&nbsp;5</a> では，アルゴリズムで求めた解のグラフが直線に見えるが，これは <code>plot()</code> の仕様によるもので，実際にはグリッドポイント上でしか最適貯蓄を計算していないことに注意．<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>筆者は射影法を初めて学んだとき，未知の関数の形状をパラメータで規定し，ある判断基準に基づいてパラメータを推定するという点にどこか計量経済学のような雰囲気を感じた．<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7"><p><strong>チェビシェフ多項式 (Chebyshev polynomials)</strong> が基底関数として頻繁に用いられている．<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/nagayu71\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      const annoteTargets = window.document.querySelectorAll('.code-annotation-anchor');
      for (let i=0; i<annoteTargets.length; i++) {
        const annoteTarget = annoteTargets[i];
        const targetCell = annoteTarget.getAttribute("data-target-cell");
        const targetAnnotation = annoteTarget.getAttribute("data-target-annotation");
        const contentFn = () => {
          const content = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          if (content) {
            const tipContent = content.cloneNode(true);
            tipContent.classList.add("code-annotation-tip-content");
            return tipContent.outerHTML;
          }
        }
        const config = {
          allowHTML: true,
          content: contentFn,
          onShow: (instance) => {
            selectCodeLines(instance.reference);
            instance.reference.classList.add('code-annotation-active');
            window.tippy.hideAll();
          },
          onHide: (instance) => {
            unselectCodeLines();
            instance.reference.classList.remove('code-annotation-active');
          },
          maxWidth: 300,
          delay: [50, 0],
          duration: [200, 0],
          offset: [5, 10],
          arrow: true,
          appendTo: function(el) {
            return el.parentElement.parentElement.parentElement;
          },
          interactive: true,
          interactiveBorder: 10,
          theme: 'quarto',
          placement: 'right',
          popperOptions: {
            modifiers: [
            {
              name: 'flip',
              options: {
                flipVariations: false, // true by default
                allowedAutoPlacements: ['right'],
                fallbackPlacements: ['right', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'left'],
              },
            },
            {
              name: 'preventOverflow',
              options: {
                mainAxis: false,
                altAxis: false
              }
            }
            ]        
          }      
        };
        window.tippy(annoteTarget, config); 
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Built with <a href="https://quarto.org/">Quarto</a></p>
</div>   
    <div class="nav-footer-center">
      <ul class="footer-items list-unstyled">
    <li class="nav-item">
    <a class="nav-link" href="../../../terms.html">
<p>© 2024, Yuki Iwanaga</p>
</a>
  </li>  
</ul>
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/Nagayu71">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="mailto:yuki.iwanaga136@gmail.com">
      <i class="bi bi-envelope" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>