{
  "hash": "0df8e268b266b3bc201e513ad82a99dd",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"マクロ経済学における有限期間モデルと数値計算の概観\"\nauthor: \"岩永悠希\"\ndate: \"2024/10/04\"\ndate-modified: \"2024/10/04\"\ncategories: [Macroeconomics, Python]\nimage: ./images/grid-search.png\nnumber-sections: true\nbibliography:\n    - ../../../assets/references.bib\n    - ../../../assets/books.bib\nabstract: 本稿では\nformat: html\n---\n\n::: {.hidden}\n\n::: {.content-visible when-format=\"html\"}\n\n$$\n\\newcommand{\\R}{\\mathbb{R}}\n\\newcommand{\\N}{\\mathbb{N}}\n\\newcommand{\\Z}{\\mathbb{Z}}\n\\newcommand{\\G}{\\mathcal{G}}\n\\newcommand{\\abs}[1]{\\lvert#1\\rvert}\n\\newcommand{\\Abs}[1]{\\left|#1\\right|}\n\\newcommand{\\norm}[1]{\\|#1\\|}\n\\newcommand{\\Norm}[1]{\\left\\|#1\\right\\|}\n\\newcommand{\\SquareBrac}[1]{\\left[#1\\right]}\n\\newcommand{\\Brace}[1]{\\left\\{#1\\right\\}}\n\\newcommand{\\Paren}[1]{\\left(#1\\right)}\n\\newcommand{\\brac}[1]{\\langle#1\\rangle}\n\\newcommand{\\Brac}[1]{\\left\\langle#1\\right\\rangle}\n\\newcommand{\\bra}[1]{\\left\\langle#1\\right|}\n\\newcommand{\\ket}[1]{\\left|#1\\right\\rangle}\n\\newcommand{\\ov}[1]{\\overline{#1}}\n\\newcommand{\\un}[1]{\\underline{#1}}\n\\newcommand{\\wt}[1]{\\widetilde{#1}}\n\\newcommand{\\wh}[1]{\\widehat{#1}}\n\\newcommand{\\pp}[2]{\\frac{\\partial #1}{\\partial #2}}\n\\newcommand{\\ppp}[3]{\\frac{\\partial #1}{\\partial #2\\partial #3}}\n\\newcommand{\\dd}[2]{\\frac{d #1}{d #2}}\n\\newcommand{\\floor}[1]{\\lfloor#1\\rfloor}\n\\newcommand{\\Floor}[1]{\\left\\lfloor#1\\right\\rfloor}\n\\newcommand{\\ceil}[1]{\\lceil#1\\rceil}\n\\newcommand{\\Ceil}[1]{\\left\\lceil#1\\rceil\\right}\n\\newcommand{\\iso}{\\overset{\\sim}{\\to}}\n\\newcommand{\\eqDescribe}[2]{\\underbrace{#1}_{\\text{#2}}}\n$$\n\n:::\n\n:::\n\n\n\n## はじめに\n\n今年の6月に『定量的マクロ経済学と数値計算』という本が出版された [@QuantMacro2024]．\n\n近年マクロ経済学のモデルが複雑になるにつれて，コンピュータを使って近似的にモデルの性質を理解するアプローチが広まっている．\n\nしかし，日本のマクロ経済学教育の中で，それを可能にする**数値計算 (numerical computation)** という分析手法を学ぶ機会は乏しい．\n\nこの状況を憂いた著者陣が，『経済セミナー』という雑誌に投稿した連載を書籍化したのが本書である．\n\n本書が扱う内容は，現代的なマクロ経済学のベースラインとなりつつあるトピックであり，教育が手薄になるのは好ましくない．\n\n> 本書が扱う内容は現在のマクロ経済学のメインストリームの１つといっても過言ではない。＜中略＞本書を通じて現代のマクロ経済分析に必要な新たな道具を身に付けるサポートをすることが、我々の目的である。(p.8)\n\n気持ちネットワーク科学をメインにやっているとはいえ，マクロ経済学徒の一人としては現代的な分析手法を学ぶ必要があると感じたため，勉強ノートを作ろうと思い立った次第である．\n\n::: {.callout-tip appearance=\"simple\" icon=\"true\"}\nこのウェブサイトのフレームワークとなっている [Quarto](https://quarto.org/) は，このようなハンズオンで学ぶスタイルの勉強ノート作成に適している． Quarto もまだまだ勉強中の身ゆえ，このブログは Quarto の勉強も兼ねている．\n:::\n\n\n## ベンチマーク・モデルとカリブレーション\n\nまず，シンプルな２期間モデルを用いて数値計算手法の基本的な使い方のイメージをつかむ．\n\n現在のマクロ経済学でベンチマークとなっている新古典派成長モデルは，この２期間モデルをモデルを多期間に拡張していき，その極限である無限期間となったものである．\n\n### ベンチマーク・モデル：２期間モデル\n\nある経済主体の人生全体での消費・貯蓄行動をモデル化しよう．\n\n経済主体は若年期に働いて所得 $w$ を獲得し，その所得を若年期の消費 $c_1$ に充てるか，それとも老後のための貯蓄 $a$ に残すかを決める問題に直面している．若年期の予算制約は，\n\n$$\nc_1 + a = w\n$$ {#eq-bc-young}\n\nであり，老年期の予算制約は若年期の貯蓄に金利 $r$ が付き，また遺産動機はないとすると，\n\n$$\nc_2 = a(1 + r)\n$$  {#eq-bc-old}\n\nで与えられる．$\\beta > 0$ を**割引因子 (discount factor)** とすると，経済主体の生涯効用は次式で与えられる：\n\n$$\nU(c_1, c_2) = u(c_1) + \\beta u(c_2).\n$$\n\n主体は若年期に意思決定を行うため，将来の消費 $c_2$ から得られる効用は割り引かれる．\n\nここで，効用関数について $u'(c) > 0$ および $u''(c) < 0$ を仮定し，主体は**消費の平準化 (consumption smoothing)** を望むものとする[^1]．\n\n[^1]: 効用関数が凹関数であるとき，経済主体はリスク回避的である．\n\n以上の設定の下で解くべき意思決定問題は，次のように定式化できる．\n\n$$\n\\begin{aligned}\n\\max_{c_1, c_2, a} & \\quad U(c_1, c_2) = u(c_1) + \\beta u(c_2) \\\\\n\\text{s.t.} & \\quad c_1 + a = w, \\\\\n& \\quad c_2 = (1+r)a. \\\\\n\\end{aligned}\n$$ {#eq-problem}\n\nラグランジアンは\n\n$$\n\\mathcal{L} = u(c_1) + \\beta u(c_2) + \\lambda_1 (w - c_1 - a) + \\lambda_2[(1+r)a - c_2]\n$$\n\nより，一階条件は\n\n$$\n\\begin{aligned}\n&0 = \\frac{\\partial\\mathcal{L}}{\\partial c_1} = u'(c_1) - \\lambda_1,\\\\\n&0 = \\frac{\\partial\\mathcal{L}}{\\partial c_2} = \\beta u'(c_2) - \\lambda_2,\\\\\n&0 = \\frac{\\partial\\mathcal{L}}{\\partial a} = -\\lambda_1 + \\lambda_2(1+r).\n\\end{aligned}\n$$\n\n整理すると @eq-euler のオイラー条件（オイラー方程式）を得る．\n\n$$\nu'(c_1) = \\beta (1+r) u'(c_2).\n$$ {#eq-euler}\n\nオイラー条件（@eq-euler）の直感的な意味は，若年期と老年期で極端に消費水準が変動することを嫌うリスク回避的な主体は，若年期の消費 $c_1$ から得られる限界効用 $u'(c_1)$ と，老年期の消費 $c_2$ から得られる限界効用の割引現在価値 $\\beta (1+r) u'(c_2)$ が一致するように消費計画を決めるということである．\n\n::: {.callout-important appearance=\"simple\" icon=\"true\"}\nところで，何をもってモデルを「解いた」と言えるのか．マクロモデルはさまざまな経済変数が登場するため，この点を整理しておかないとすぐに迷子になる．\n\nこのモデルの内生変数は $c_1$ と $a$ であり，外生変数は $w$ であるから[^2]，モデルを解くにはある所得 $w$ のもとでの主体の貯蓄関数 $g(w)$ と消費関数 $h(w)$ を導出すれば良い：\n\n$$\n\\begin{aligned}\na &= g(w), \\\\\nc_1 &= h(w).\n\\end{aligned}\n$$\n\nこの例のように，\n\n$$\n\\text{内生変数} = f(\\text{外生変数})\n$$\n\nと内生変数が外生変数の関数として書けるとき，「モデルが解けた」という．\n:::\n\n[^2]: 経済学では，方程式の解として決まる変数を**内生変数 (endogenous variable)**，方程式を解く前に値がすでに決まっている変数を**外生変数 (exogenous variable)** と呼ぶ[@Math4Econ1996]．外生変数は単にパラメータとか状態変数とも言われる．\n\n### カリブレーション\n\n２期間モデルは人間にとってはシンプルなモデルだが，コンピュータにとってはそうではない．\n\nというのも，効用関数 $u(c)$ という表現は抽象的で，コンピュータには理解できないからである．\n\nそこで，コンピュータが理解できる形で効用関数を「特定化」する必要がある．\n\nここでは，マクロ経済学で頻繁に使われる**相対的リスク回避度一定 (constant relative risk aversion: CRRA)** 型効用関数を仮定する．\n\n$$\nu(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}.\n$$ {#eq-crra}\n\nリスクが存在するモデルであれば，$\\gamma$ は**相対的リスク回避度 (coefficient of relative risk aversion)** であり，同時に**異時点間の代替の弾力性 (intertemporal elasticity of substitution)** の逆数である．\n\n@eq-crra をコンピュータが認識できるように Python で書くと，次のようになる．\n\n::: {#b6ff4af4 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\ndef CRRA(c, gamma):\n    if gamma != 1.0:\n        util = c**(1.0 - gamma) / (1.0 - gamma)\n    else:\n        util = np.log(c) # <1>\n    return util\n```\n:::\n\n\n1.  $\\gamma = 1$ の場合に $u(c) = \\log c$ としているのは @eq-crra が $c \\to 1$ の極限で発散するため，次式のようにロピタルの定理で解消した結果である．$$\n\\begin{aligned}\n\\lim_{\\gamma\\to1} u(c) \n&= \\lim_{\\gamma\\to1} \\frac{c^{1-\\gamma}}{1-\\gamma} \\\\\n&= \\lim_{\\gamma\\to1} \\frac{-c^{1-\\gamma} \\log c}{-1} \\\\\n&= \\lim_{\\gamma\\to1} c^{1-\\gamma}\\log c \\\\\n&= \\log c\n\\end{aligned}$$\n\n実際にプログラムを動かす際は，関数形の特定に加えて具体的にパラメータの値を決める必要があるが，このように関数形を特定してパラメータを定める一連の作業を**カリブレーション (calibration)** と呼ぶ．\n\n異なる `gamma` の下で CRRA 型効用関数（@eq-crra）を可視化したものが @fig-crra である．\n\n::: {#cell-fig-crra .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport japanize_matplotlib\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\n# c の範囲を指定して曲線をプロット\nc = np.linspace(start=0.1, stop=1.0, num=100) # <1>\n\ngammas = [1, 1.5, 2]\nfor gamma in gammas:\n    u = CRRA(c, gamma)\n    ax.plot(c, u, label=f'gamma = {gamma}')\nax.set_title(\"Utility Function for Different gamma values\")\nax.set_xlabel(r\"$c$\")\nax.set_ylabel(r\"$u(c)$\")\nax.legend()\nax.grid()\npass\n```\n\n::: {.cell-output .cell-output-display}\n![CRRA 型効用関数](numerical_computation_files/figure-html/fig-crra-output-1.png){#fig-crra width=594 height=448}\n:::\n:::\n\n\n1. 0.1 から 10 までの値 (0 は定義できないので 0.1 から)\n\nベンチマーク・モデルでは人生を 2 期間に分けているので，モデル上の 1 期間を 30 年と想定する．\nそのため，割引因子 $\\beta$ と金利 $r$ は年率ではなく 30 年間の値を使う．\n\n今回は実際に 1 期間を 30 年でカリブレートしている @song2012rotten の値を拝借する．割引因子は年率で $\\beta = 0.985$ として，1 期間は 30 年なので 30 乗する（$\\beta = 0.985^{30}$）．金利は年率で $2.5\\%$ と設定すると $1+r = 1.025^{30}$ となる．相対的リスク回避度は，よく使われる値の $\\gamma = 2$ としておく．\n\n::: {#d4e8b42e .cell execution_count=3}\n``` {.python .cell-code}\nbeta = 0.985**30        # 割引因子\ngamma = 2.0             # 相対的危険回避度\nr = 1.025**30 - 1.0     # 金利\n```\n:::\n\n\n### 解析解の性質\n\n数値計算に入る前に，２期間モデルの解析解の性質を簡単に確認しておく．今回のモデルはシンプルなので，貯蓄関数 $a = g(w)$ を手計算で求めることができる．\n\n$$\n% \\begin{equation}\na = \\frac{w}{1+(1+r)\\{\\beta(1+r)\\}^{-1/\\gamma}}\n% \\end{equation}\n$$ {#eq-saving}\n\n:::{.callout-note icon=\"false\" collapse=\"true\"}\n## 導出\n\nオイラー条件（@eq-euler）に予算制約の @eq-bc-young と @eq-bc-old を代入すると，\n\n$$\n\\begin{aligned}\n(w-a)^{-\\gamma} &= \\beta(1+r)\\SquareBrac{(1+r)a}^{-\\gamma} \\\\\n(w-a) &= \\SquareBrac{\\beta(1+r)}^{-1/\\gamma}(1+r)a \\\\\nw &= \\Brace{1+\\SquareBrac{\\beta(1+r)}^{-1/\\gamma}(1+r)}a.\n\\end{aligned}\n$$\n\n:::\n\nこれがモデルから導出される真の貯蓄関数であり，内生変数 $a$ が外生変数 $w, r, \\beta, \\gamma$ で表されているので，これでモデルは解けている．\n\n貯蓄関数（@eq-saving）は若年期の所得 $w$ の連続な線形の増加関数になっており，そのグラフを可視化したものが @fig-saving である．\n\n::: {#cell-fig-saving .cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\n# 貯蓄関数\ndef saving(w, beta, r, gamma):\n    return w / (1 + (1+r) * (beta*(1+r)) **(-1/gamma))\n\nfig, ax = plt.subplots()\n\nw = np.linspace(start=0, stop=1.0, num=100)\na = saving(w, beta, r, gamma)\nax.plot(w, a, c=\"#FF7A72\")\nax.set(title=\"貯蓄関数\", xlabel=\"若年期の所得: \"+r\"$w$\", ylabel=\"若年期の貯蓄: \"+r\"$a=g(w)$\", xlim=(0,1), ylim=(0,0.4))\nax.grid()\npass\n```\n\n::: {.cell-output .cell-output-display}\n![解析的に求めた貯蓄関数](numerical_computation_files/figure-html/fig-saving-output-1.png){#fig-saving width=610 height=451}\n:::\n:::\n\n\n## 【実践】数値計算\n\n### 離散近似とグリッド\n\n貯蓄関数（@eq-saving）は連続関数であるが，コンピュータは連続という概念をそのままの形では理解できない．\n\nそこで，数値計算においては基本的に，連続な変数を有限の $N$ 個の点に**離散化 (discretize)** して考える必要がある．\n\n#### グリッド上で計算する\n\n若年期の所得 $w$ がとりうる値は，$w_i \\in \\{w_1,\\ldots,w_N\\}$ の範囲にあるとする．\n\n::: {.callout-important appearance=\"simple\"}\nコンピュータは無限を扱えないので，$w \\in [0, \\infty)$ や $w \\in (-\\infty, \\infty)$ のような範囲を扱うことはできない．\n数値計算において，定義域は必ず**有界 (finite)**である必要がある．\n:::\n\n所得を $N$ 個に離散化するということは，若年期の所得に応じて $N$ 種類の経済主体が存在している状況を作り出すということである．\n\nこの離散的な点の集まりを**グリッド (grid)** あるいは**ノード (node)** と呼ぶ．\nまた，それぞれの点は**グリッドポイント (grid point)** あるいは**評価点 (evaluation point)** と呼ばれている．\n\nここでは単純に，若年期の所得 $w$ は $[0.1, 1]$ 区間の間に $0.1$ 刻みで $10$ 個の点\n\n$$\nw_i \\in \\{0.1, 0.2,\\ldots, 1.0\\}\n$$\n\nとして存在していると考える．\n\n::: {#4aa25539 .cell execution_count=5}\n``` {.python .cell-code}\nnw = 10       # 所得グリッドの数\nw_min = 0.1   # 所得の最大値\nw_max = 1.0   # 所得の最小値\ngrid_w = np.linspace(start=0.1, stop=1.0, num=10)\nprint(grid_w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]\n```\n:::\n:::\n\n\n::: {.callout-important appearance=\"simple\"}\nこの意思決定問題では $w_i = 0$ を含めると若年期も老年期も消費ができなくなってしまうため，最小値は正値にしておく必要がある．\n:::\n\n### 状態変数と制御変数がともに離散の場合：グリッドサーチ {#sec-grid-search}\n\n::: {.callout-tip appearance=\"simple\"}\n## 用語の導入\n最適化問題を解く際にすでに決まっている若年期の所得 $w$ を**状態変数 (state variable)** と呼び，意思決定において選択する若年期の貯蓄 $a$ を**制御変数 (control variable)** と呼ぶ．\nまた，貯蓄関数のような意思決定関数は**政策関数 (policy function)** と呼ばれる．\n:::\n\n\nまずは，所得 $w$ と資産 $a$ がともに離散的な場合に２期間モデルを解く方法を見る．\n\nすなわち，状態変数 $w$ だけでなく，制御変数 $a$ についても離散化を行う．\n\nここでは\n\n$$\na_j \\in \\{0.025, 0.05, 0.075, 0.1, \\ldots, 1.0\\}\n$$\n\nと $0.025$ 刻みで $40$ 個のグリッドをとる^[$w_i$ と同じ離散化をすると，$w = 0.1$ のときに　1 期目の消費 $c_1 = w - a$ がゼロか負値しかとれず，最適貯蓄あるいは最適消費が存在しなくなってしまうため．]．\n\n::: {#a64d6055 .cell execution_count=6}\n``` {.python .cell-code}\nna = 40       # 貯蓄グリッドの数\na_min = 0.025 # 貯蓄の最小値\na_max = 1.0   # 貯蓄の最大値\ngrid_a = np.linspace(start=a_min, stop=a_max, num=na)\nprint(grid_a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.025 0.05  0.075 0.1   0.125 0.15  0.175 0.2   0.225 0.25  0.275 0.3\n 0.325 0.35  0.375 0.4   0.425 0.45  0.475 0.5   0.525 0.55  0.575 0.6\n 0.625 0.65  0.675 0.7   0.725 0.75  0.775 0.8   0.825 0.85  0.875 0.9\n 0.925 0.95  0.975 1.   ]\n```\n:::\n:::\n\n\nこのような離散化を行うと，解くべき効用最大化問題（@eq-problem）は，所与の $w_i$ について，\n\n$$\n\\max_{a_j} \\quad \n\\frac{[w_i-a_j]^{1-\\gamma}}{1-\\gamma} + \\beta\\frac{[(1+r)a_j]^{1-\\gamma}}{1-\\gamma}\n$$ {#eq-obj}\n\nと書き直すことができる．\n\n組み合わせの数は，所得 $w_i$ と資産 $a_j$ がそれぞれ $10$ 通りと $40$ 通りあるので， $400$ 通りとなる．\n\nそして各所得 $w_i$ のもとで $40$ 種類の資産 $a_j$ の中から生涯効用（@eq-obj）を最大化する資産 $a^*$ を求めれば良いので，これくらいであれば「総当たり」で求めることができる．\n\n::: {#4c80a00d .cell execution_count=7}\n``` {.python .cell-code}\nobj = np.zeros((na, nw)) # <1>\n\n# 状態変数と制御変数のすべての組み合わせ (w,a) について生涯効用を計算\nfor i in range(nw):\n    for j in range(na):\n        c = grid_w[i] - grid_a[j]\n        if c > 0:\n            obj[j, i] = CRRA(c, gamma) + beta * CRRA((1+r)*grid_a[j], gamma)\n        else: # <2>\n            obj[j, i] = -10000.0 \n```\n:::\n\n\n1. 各 $(w_i, a_j)$ での生涯効用を格納する`na` $\\times$ `nw` ゼロ行列\n2. 消費が負になる場合，負の効用を与えて最適化でこの値が選ばれないようにしておく\n\n試しに，`w = 0.5, 0.8, 1.0` のときの生涯効用を可視化してみよう（@fig-obj）．\n\n::: {#cell-fig-obj .cell execution_count=8}\n``` {.python .cell-code code-fold=\"true\"}\nfig, ax = plt.subplots()\nax.plot(grid_a, obj[:,4], c=\"b\", label=\"w=0.5\")\nax.plot(grid_a, obj[:,7], c=\"r\", label=\"w=0.8\")\nax.plot(grid_a, obj[:,9], c=\"g\", label=\"w=1.0\")\nax.set(xlabel=\"若年期の貯蓄(老年期の資産): \"+r\"$a$\", ylabel=\"生涯効用: \"+r\"$U(c_1,c_2)$\", xlim=(0,1), ylim=(-10,0))\nax.legend()\nax.grid(ls=\"--\")\npass\n```\n\n::: {.cell-output .cell-output-display}\n![生涯効用](numerical_computation_files/figure-html/fig-obj-output-1.png){#fig-obj width=606 height=437}\n:::\n:::\n\n\n@fig-obj では若年期の所得 $w_i$ の下での生涯効用 $U(c_1, c_2)$ が凹関数として可視化されている．\n\n直感的にそれぞれの山の頂上に対応する貯蓄点が，求めたい最適貯蓄だとわかるだろう．\n\nそこで，若年期の所得 $w_i$ ごとに最適な貯蓄点 $a_j$ を計算し，求めた貯蓄関数を可視化する（@fig-policy）．\n\n::: {#cell-fig-policy .cell execution_count=9}\n``` {.python .cell-code}\npol = np.zeros(nw)                               # <1>\nfor i in range(nw):\n    maximizer = np.argmax(obj[:, i])             # <2>\n    pol[i] = grid_a[maximizer]\n\nfig, ax = plt.subplots()\nax.plot(grid_w, saving(grid_w, beta, r, gamma), c=\"#FF7A72\",label=\"解析解\")\nax.plot(grid_w, pol, c=\"#78C2AD\", marker=\"o\", label=\"グリッドサーチ\")\nax.set(title=\"貯蓄関数\", xlabel=\"若年期の所得: \"+r\"$w$\", ylabel=\"若年期の貯蓄: \"+r\"$a=g(w)$\")\nax.grid(ls=\"--\")\nax.legend()\npass\n```\n\n::: {.cell-output .cell-output-display}\n![グリッドサーチで求めた貯蓄関数](numerical_computation_files/figure-html/fig-policy-output-1.png){#fig-policy width=600 height=451}\n:::\n:::\n\n\n1. 政策関数（貯蓄関数）を格納するゼロベクトル\n2. 生涯効用が最大値をとる点を探す\n\n@fig-policy を見ると，グリッドサーチで求めた最適貯蓄（緑色の点）が，解析解（赤色の直線）からあまり離れていないことがわかる．\n\n::: {.callout-important appearance=\"simple\"}\nグリッドサーチのグラフは点同士を直線でつないだ折れ線グラフのように見えるが，これは `plot()` 関数の仕様によるものである．実際には，状態変数 $w$ のグリッドポイント上でしか最適貯蓄 $a$ を求めていないことに注意されたい．\n:::\n\nグリッドサーチで精度を上げるには，離散化するグリッドの数を増やせば良さそうだが，考えているモデルによっては次のセクションで扱う「次元の呪い」という問題にぶつかる．\n\n#### 注意点：次元の呪い\n\n状態変数と制御変数をどちらも離散化して，とりうる全ての組み合わせを計算するというグリッドサーチのアプローチは，単純ではあるが複雑な非線形モデルにも使えるのでなかなか侮れない．\n\nたとえば，政策関数の形状や性質がよくわかっていないモデルを解く場合，とりあえずグリッドを切ってモデルの性質を大雑把に掴むというアプローチは有効である．\n\nしかし，このアプローチは**次元の呪い (curse of dimensionality)** の影響をダイレクトに受けるので，計算に時間がかかる傾向にある．\n\n状態変数の数が $n$ 個のとき，最適貯蓄を計算する必要のあるグリッドポイントの数は\n\n$$\n(\\text{状態変数のグリッド数})^n\n$$\n\nで与えられる．したがって，たとえば教育水準の違いや性別の違いを考慮できるように若年期における状態変数を増やしていくと，計算時間は指数的に増えてしまう．\n\n::: {.callout-important}\n## 次元の呪い\n\n状態変数を増やせば増やすほど，計算時間は指数的に増える．そのため，現実的な計算時間で複雑なモデルを高い精度で解くための工夫が常に求められる．\n:::\n\n#### オブジェクト指向プログラミング {#sec-obj-oriented}\n\n数値計算では，コンピュータが理解できるように関数を特定化してパラメータを設定するカリブレーションという作業が必要なのであった．\n\nここまでの実装では，逐一関数を定義してパラメータを指定していた．\n\nしかし，その方法ではパラメータが変わった時にモデルの振る舞いがどう変わるかを分析する比較静学のような場面で苦労しそうなのは容易に想像できる．\n\nそこで，オブジェクト指向プログラミングの**クラス (class)** という機能でモデルのテンプレートを作っておくと便利である．\n\n```{{python}}\nclass Models:\n    def __init__(self, beta, gamma, r, nw, w_min, w_max, grid_w, na, a_min, a_max, grid_a):\n        self.beta = beta\n        self.gamma = gamma\n        self.r = r\n        self.nw = nw\n        self.w_min = w_min\n        self.w_max = w_max\n        self.grid_w = grid_w\n        self.na = na\n        self.a_min = a_min\n        self.a_max = a_max\n        self.grid_a = grid_a\n```\n\nカリブレーションを行う際は `Models` を定義した上で，次の `Calibration()` 関数を実行する．\n\n```{{python}}\ndef Calibration():\n    beta = 0.985 ** 30\n    gamma = 2.0\n    r = 1.025**30 - 1.0\n    nw = 10\n    w_min = 0.1\n    w_max = 1.0\n    na = 40\n    a_min = 0.025\n    a_max = 1.0\n\n    grid_w = np.linspace(w_min, w_max, nw)\n    grid_a = np.linspace(a_min, a_max, na)\n    return Models(beta, gamma, r, nw, w_min, w_max, grid_w, na, a_min, a_max, grid_a)\n```\n\nこのノードでもこれ以降は，さまざまなパラメータをクラスを使って管理する．\n\n\n### 最適化アルゴリズム {#sec-optimize}\n\nグリッドサーチはモデルを拡張した場合に計算量が指数的に増加するのに加え，グリッド数を節約すると精度が悪化するという問題を抱えていた．\n\n実際，真の貯蓄関数は @fig-saving のように線形である一方，グリッドサーチで求めた貯蓄関数は @fig-policy にあるように直線ではない．\n\nそこで，状態変数 $w$ は @sec-grid-search と同様に離散化するが，連続な制御変数 $a$ を許容するより洗練されたアプローチを用いる．\n\nよって，今考えている最適化問題は次式で表される．\n\n$$\n\\max_{a\\in\\R} \\quad \n\\frac{[w_i-a]^{1-\\gamma}}{1-\\gamma} + \\beta\\frac{[(1+r)a]^{1-\\gamma}}{1-\\gamma}\n$$ {#eq-prob25}\n\n@eq-prob25 のような最適化問題を数値計算で解くには，数値計算ソフトに標準的に実装されている最適化ライブラリを用いれば良い．\n\n大抵は，目的関数とその関数のパラメータを入力として受け取り，目的関数の最大値や最小値を探索する仕様になっている．\n\n最適化問題（@eq-prob25）であれば，カリブレーションしたパラメータ $\\{\\beta, \\gamma, r\\}$ を所与として，各状態変数 $w_i \\in \\Brace{w_1, \\ldots, w_N}$ の下で生涯効用の最大値とそれを与える最大元 $a$ を探索してくれる．\n\n#### 実装\n\nまず，カリブレーションを @sec-obj-oriented で導入した方法で行う．\n\n::: {#cf064701 .cell execution_count=10}\n``` {.python .cell-code}\nclass Models:\n    def __init__(self, beta, gamma, r, nw, w_min, w_max, grid_w):\n        self.beta = beta\n        self.gamma = gamma\n        self.r = r\n        self.nw = nw\n        self.w_min = w_min\n        self.w_max = w_max\n        self.grid_w = grid_w\n\ndef Calibration():\n    beta = 0.985 ** 30\n    gamma = 2.0\n    r = 1.025**30 - 1.0\n    nw = 10\n    w_min = 0.1\n    w_max = 1.0\n\n    grid_w = np.linspace(w_min, w_max, nw)\n    return Models(beta, gamma, r, nw, w_min, w_max, grid_w)\n```\n:::\n\n\n`Calibration()` 関数を実行することで，`Calibration()` 内で定義されたパラメータを情報として持つ `Models` インスタンスが生成されるので，`params` に代入しておく．\n\n::: {#a10b0f7a .cell execution_count=11}\n``` {.python .cell-code}\nparams = Calibration()\n```\n:::\n\n\nここでは，`scipy` の `optimize` モジュールにある [`fminbound()` 関数](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fminbound.html#scipy.optimize.fminbound)を使って最適化問題（@eq-prob25）を解く^[`fminbound()` のように数値計算によって方程式を解くアルゴリズムのことを**ソルバー (solver)** と呼ぶ．]．\n\n::: {#c9a8c206 .cell execution_count=12}\n``` {.python .cell-code}\nfrom scipy import optimize\n```\n:::\n\n\nでは，`optimize.fminbound()` に渡す目的関数を定義しよう．最小化問題に変換するために $-1$ をかけている．\n\n$$\n\\text{obj}(a, w_i;\\beta, \\gamma, r) = -\\Brace{\\frac{[w_i-a]^{1-\\gamma}}{1-\\gamma} + \\beta\\frac{[(1+r)a]^{1-\\gamma}}{1-\\gamma}}\n$$\n\n::: {#53d1125c .cell execution_count=13}\n``` {.python .cell-code}\ndef obj(a, w_i, params):\n    c = w_i - a\n    if c > 0:\n        life_util = CRRA(c, params.gamma) + params.beta * CRRA((1+params.r)*a, params.gamma)\n    else:\n        life_util = -100000.0\n    return -1.0 * life_util\n```\n:::\n\n\n::: {.callout-important appearance=\"simple\"}\n上の `obj()` は `a, w_i, params` の３つの引数を持つが，実際に `optimize.fminbound()` に渡すときは，最適化を行う `a` だけの関数にしておく必要がある．\n:::\n\n所与の状態変数 $w_i$ に対して制御変数 $a$ についての最適化問題を解けば良いので，`grid_w` についての `for` ループ内で `optimize.fminbound()` を使えば良い．\n\n::: {#d6fb94ba .cell execution_count=14}\n``` {.python .cell-code}\nopt_a = np.zeros(params.nw) # <1>\n\nfor i, w_i in enumerate(params.grid_w):\n    obj_specified = lambda a: obj(a, w_i, params)                     # <2>\n    opt_a[i] = optimize.fminbound(obj_specified, w_i*0.01, w_i*2.0)\nprint(f\"最適貯蓄の配列: \\n{opt_a}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n最適貯蓄の配列: \n[0.03550017 0.07100034 0.10650385 0.14200403 0.17750421 0.21300505\n 0.24850589 0.28400673 0.31950757 0.35500841]\n```\n:::\n:::\n\n\n1. 各 $w_i$ の下での最適貯蓄を格納する配列\n2. `optimize.fminbound()` に渡すために，`obj()` を `a` だけの関数にする\n\n`opt_a` には `grid_w` の各 $w_i$ に対する最適貯蓄 $a$ が格納してある．これを可視化したものが @fig-optimization である．\n\n::: {#cell-fig-optimization .cell execution_count=15}\n``` {.python .cell-code}\nfig, ax = plt.subplots()\nax.grid(ls=\"--\")\nax.scatter(params.grid_w, saving(params.grid_w, params.beta, params.r, params.gamma), c=\"#FF7A72\",label=\"解析解\")\nax.plot(params.grid_w, opt_a, c=\"#78C2AD\",label=\"アルゴリズム\")\nax.set(title=\"貯蓄関数\", xlabel=\"若年期の所得: \"+r\"$w$\", ylabel=\"若年期の貯蓄: \"+r\"$a=g(w)$\")\nax.legend()\npass\n```\n\n::: {.cell-output .cell-output-display}\n![最適化アルゴリズムから導出した貯蓄関数](numerical_computation_files/figure-html/fig-optimization-output-1.png){#fig-optimization width=600 height=451}\n:::\n:::\n\n\n同じグリッドポイントを使っているが，グリッドサーチで求めた @fig-policy と違って，最適化アルゴリズムで導出した @fig-optimization は解析的な解（@fig-saving）が示す綺麗な直線になっており，計算精度が大幅に改善された様子がわかる^[@fig-optimization では，アルゴリズムで求めた解のグラフが直線に見えるが，これは 'plot()' の仕様によるもので，実際にはグリッドポイント上でしか最適貯蓄を計算していないことに注意．]．\n\nこれは制御変数 $a$ がとりうる値を連続値にしたことに起因する．\n\n### １階条件を使う\n\nモデルの解が満たすべきオイラー条件（@eq-euler）をうまく使って数値計算を行うアプローチもある．\n\nここでは，オイラー条件を求根問題に落とし込んで解く方法（@sec-root-finding）と，政策関数自体をパラメトリックに近似する方法（@sec-projection）を扱う．\n\n#### 非線形方程式の求根問題 {#sec-root-finding}\n\nオイラー条件（@eq-euler）に予算制約を代入すると次式を得る．\n\n$$\nu'(w-a) = \\beta(1+r)u'((1+r)a)\n$$ {#eq-2.7}\n\n状態変数 $w$ を $w_i$ と離散化して，それぞれの変数の役割を見てみると\n\n$$\nu'(\\eqDescribe{w_i}{given} - \\eqDescribe{a}{control}) = \n\\eqDescribe{\\beta(1+r)}{parameter}u'(\\eqDescribe{(1+r)}{parameter}\\ \\eqDescribe{a}{control})\n$$\n\nなので，未知変数は $a$ だけである．そこで，@eq-2.7 を変形して次式で**残差関数 (residual function)** を定義する：\n\n$$\nR(a;w_i) \\equiv\n\\beta(1+r)\\frac{u'((1+r)a)}{u'(w_i-a)} - 1.\n$$ {#eq-resid}\n\n@eq-resid を使うと，オイラー条件を満たす制御変数 $a$ を見つける問題を，\n\n$$\nR(a;w_i) = 0\n$$\n\nとなる $a$ を探すという **求根（ゼロ点）問題 (root-finding problem)** に変換することができる．\n\n一般に，オイラー条件を変換して得た残差関数（@eq-resid）は，複雑な形をした非線形方程式である可能性があるが，非線形方程式のゼロ点を探すアルゴリズムの研究は長い歴史を持つため，様々なアプローチが考案されている．\n\n##### 実装\n\n求根問題は [`scipy.optimize.fsolve()` 関数](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve)で解くことができる．\nここではカリブレーションは @sec-optimize のものを再び使用する．\n\nまずはソルバーに渡す残差関数（@eq-resid）を実装しよう．残差関数内にある限界効用 (marginal utility) は\n\n$$\nu'(c) = c^{-\\gamma}\n$$\n\nで与えられるので，Python で表すと次のようになる．\n\n::: {#8a2fa672 .cell execution_count=16}\n``` {.python .cell-code}\ndef marginal_util(c, gamma):\n    return c ** (- gamma)\n```\n:::\n\n\nこれを用いると残差関数は次のように実装できる．\n\n::: {#819bb158 .cell execution_count=17}\n``` {.python .cell-code}\ndef resid(a, w_i, params):\n    c = w_i - a\n    if c > 0:\n        mu_y = marginal_util(c, params.gamma) # <1>\n    else:\n        mu_y = 10000.0\n    mu_o = marginal_util((1+params.r)*a, params.gamma) # <2>\n    return params.beta * (1+params.r) * (mu_o/mu_y) - 1.0\n```\n:::\n\n\n1. 若年期の限界効用\n2. 老年期の限界効用\n\n@sec-optimize と同様に，ソルバーを使って各状態変数 $w_i$ の下で最適貯蓄を求めていく．\n\n::: {#eacb8b5c .cell execution_count=18}\n``` {.python .cell-code}\nopt_a = np.zeros(params.nw)                                 # <1>\n\nfor i, w_i in enumerate(params.grid_w):\n    resid_specified = lambda a: resid(a, w_i, params)       # <2>\n    opt_a[i] = optimize.fsolve(resid_specified, x0=0.01)[0] # <3>\nprint(f\"最適貯蓄の配列: \\n{opt_a}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n最適貯蓄の配列: \n[0.03550089 0.07100178 0.10650266 0.14200355 0.17750444 0.21300533\n 0.24850621 0.2840071  0.31950799 0.35500888]\n```\n:::\n:::\n\n\n1. 各 $w_i$ の下での最適貯蓄を格納する配列\n2. `optimize.fsolve()` に渡すために，`resid()` を `a` だけの関数にする\n3. `optimize.fsolve()` の返り値の最初の要素に欲しい最適な $a$ が格納されている\n\n結果を図示した @fig-root-finding を見ると，アルゴリズムで求めた解が解析解の直線上に乗っている様子がわかる．\n\n::: {#cell-fig-root-finding .cell execution_count=19}\n``` {.python .cell-code}\nfig, ax = plt.subplots()\nax.grid(ls=\"--\")\nax.plot(params.grid_w, saving(params.grid_w, params.beta, params.r, params.gamma), c=\"#FF7A72\",label=\"解析解\")\nax.scatter(params.grid_w, opt_a, c=\"#78C2AD\", label=\"アルゴリズム\")\nax.set(title=\"貯蓄関数\", xlabel=\"若年期の所得: \"+r\"$w$\", ylabel=\"若年期の貯蓄: \"+r\"$a=g(w)$\")\nax.legend()\npass\n```\n\n::: {.cell-output .cell-output-display}\n![求根アルゴリズムから導出した貯蓄関数](numerical_computation_files/figure-html/fig-root-finding-output-1.png){#fig-root-finding width=600 height=451}\n:::\n:::\n\n\n#### パラメトリックな近似：射影法 {#sec-projection}\n\n\n\n## References {.unnumbered}\n\n",
    "supporting": [
      "numerical_computation_files"
    ],
    "filters": [],
    "includes": {}
  }
}